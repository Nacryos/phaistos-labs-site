<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Phaistos Labs</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      background: #000;
      color: #fff;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow-x: hidden;
      overscroll-behavior-y: contain;
    }
    canvas { display: block; touch-action: pan-y; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }

    /* Fixed graph background */
    #graph-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }

    /* Hero section — full viewport, centered text over graph */
    #hero {
      position: relative;
      z-index: 2;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: center;
      padding-left: clamp(40px, 6vw, 100px);
      pointer-events: none;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    #hero-title {
      font-size: clamp(48px, 7vw, 88px);
      font-weight: 700;
      letter-spacing: -1.5px;
      color: #fff;
      text-align: left;
      line-height: 1.05;
      transition: opacity 0.1s, transform 0.1s;
    }
    #hero-subtitle {
      font-size: clamp(13px, 1.6vw, 18px);
      font-weight: 300;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.45);
      margin-top: 16px;
      text-align: left;
      transition: opacity 0.1s, transform 0.1s;
    }
    #typewriter-cursor {
      color: rgba(255, 255, 255, 0.45);
      animation: cursorBlink 0.6s step-end infinite;
      font-weight: 100;
    }
    @keyframes cursorBlink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    /* Scroll indicator — sits above the "Learn more" label */
    #scroll-indicator {
      position: absolute;
      bottom: 72px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      opacity: 0.35;
      transition: opacity 0.5s ease;
      animation: scrollPulse 2.5s ease-in-out infinite;
    }
    #scroll-indicator span {
      font-size: 11px;
      font-weight: 400;
      letter-spacing: 3px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
    }
    #scroll-indicator .chevron {
      width: 20px;
      height: 20px;
      border-right: 1.5px solid rgba(255, 255, 255, 0.4);
      border-bottom: 1.5px solid rgba(255, 255, 255, 0.4);
      transform: rotate(45deg);
    }
    @keyframes scrollPulse {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(5px); }
    }

    /* Graph shimmer label */
    #graph-label {
      position: fixed;
      bottom: 28px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 3;
      font-size: 13px;
      font-weight: 400;
      letter-spacing: 1px;
      color: transparent;
      background: linear-gradient(
        90deg,
        rgba(255,255,255,0.15) 0%,
        rgba(255,255,255,0.5) 50%,
        rgba(255,255,255,0.15) 100%
      );
      background-size: 200% 100%;
      -webkit-background-clip: text;
      background-clip: text;
      animation: shimmer 4s linear infinite;
      pointer-events: auto;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
      transition: opacity 0.3s;
    }
    #graph-label:hover {
      opacity: 0.9 !important;
    }

    /* Graph info popup */
    #graph-info {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 200;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 80px;
      background: transparent;
    }
    #graph-info-box {
      background: rgba(5, 5, 7, 0.3);
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 6px;
      padding: 20px 26px;
      color: #ccc;
      font-family: 'Courier New', 'Consolas', monospace;
      font-size: 12.5px;
      line-height: 1.7;
      max-width: 460px;
      min-width: 300px;
      box-shadow: 0 8px 40px rgba(0, 0, 0, 0.7);
      animation: fadeUpIn 0.35s ease-out;
    }
    @keyframes fadeUpIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Content section below the fold */
    #content {
      position: relative;
      z-index: 4;
      min-height: 100vh;
      background: linear-gradient(
        to bottom,
        rgba(0, 0, 0, 0) 0%,
        rgba(0, 0, 0, 0.7) 8%,
        rgba(0, 0, 0, 0.92) 20%,
        #000 35%
      );
      padding: 0 24px;
    }
    #content-inner {
      max-width: 680px;
      margin: 0 auto;
      padding-top: 120px;
      padding-bottom: 120px;
    }
    #content-inner h2 {
      font-size: clamp(28px, 4vw, 42px);
      font-weight: 600;
      letter-spacing: -0.5px;
      color: #fff;
      margin-bottom: 32px;
      line-height: 1.2;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }
    #content-inner h2.visible {
      opacity: 1;
      transform: translateY(0);
    }
    #content-inner p {
      font-size: 16px;
      font-weight: 350;
      line-height: 1.85;
      color: rgba(255, 255, 255, 0.55);
      margin-bottom: 24px;
      opacity: 0;
      transform: translateY(25px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }
    #content-inner p.visible {
      opacity: 1;
      transform: translateY(0);
    }
    #content-inner .contact {
      margin-top: 60px;
      padding-top: 32px;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      font-size: 14px;
      font-weight: 400;
      color: rgba(255, 255, 255, 0.35);
      letter-spacing: 0.3px;
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.8s ease, transform 0.8s ease;
    }
    #content-inner .contact.visible {
      opacity: 1;
      transform: translateY(0);
    }
    #content-inner .contact a {
      color: rgba(255, 255, 255, 0.55);
      text-decoration: none;
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      transition: color 0.2s, border-color 0.2s;
    }
    #content-inner .contact a:hover {
      color: rgba(255, 255, 255, 0.8);
      border-color: rgba(255, 255, 255, 0.4);
    }

    /* Tooltip (unchanged) */
    #tooltip {
      position: fixed;
      display: none;
      background: rgba(5, 5, 7, 0.25);
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 5px;
      padding: 14px 18px;
      color: #ccc;
      font-family: 'Courier New', 'Consolas', monospace;
      font-size: 12.5px;
      line-height: 1.7;
      pointer-events: none;
      max-width: 400px;
      min-width: 260px;
      z-index: 100;
      box-shadow: 0 4px 24px rgba(0,0,0,0.6);
    }
    .tt-header {
      color: #ffffff;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1.5px;
      margin-bottom: 6px;
      text-transform: uppercase;
      border-bottom: 1px solid rgba(255,255,255,0.12);
      padding-bottom: 6px;
    }
    .tt-row {
      display: flex;
      gap: 10px;
    }
    .tt-label {
      color: rgba(255,255,255,0.3);
      min-width: 80px;
      flex-shrink: 0;
    }
    .tt-value {
      color: rgba(255,255,255,0.7);
    }
    .tt-status-alive { color: #5c5; }
    .tt-status-extinct { color: #e55; }
    .tt-status-moribund { color: rgba(255,255,255,0.5); }
    .tt-pinned {
      position: absolute;
      top: 6px;
      right: 10px;
      font-size: 10px;
      color: rgba(255,255,255,0.2);
      letter-spacing: 1px;
    }
    /* Leader-line labels */
    #leader-labels {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 90;
      overflow: hidden;
    }
    .leader-label {
      position: absolute;
      top: 0;
      left: 0;
      width: 0;
      height: 0;
    }
    .leader-svg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    .leader-svg polyline {
      fill: none;
      stroke: rgba(255,255,255,0.7);
      stroke-width: 1;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    .leader-text {
      position: fixed;
      font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
      font-size: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: rgba(255,255,255,0.85);
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 0 8px rgba(0,0,0,0.8), 0 1px 3px rgba(0,0,0,0.6);
    }
    @media (max-width: 768px) {
      .leader-text {
        font-size: 8px;
        letter-spacing: 0.8px;
      }
      .leader-svg polyline {
        stroke-width: 0.75;
        stroke: rgba(255,255,255,0.6);
      }
      #leader-labels {
        /* hide labels entirely when search panel is open on mobile (it's full-width) */
      }
    }

    /* Search toggle button */
    #search-toggle {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 150;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(5, 5, 7, 0.30);
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      transition: background 0.2s, border-color 0.2s, opacity 0.3s;
      opacity: 0.6;
    }
    #search-toggle:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.15);
      opacity: 1;
    }
    #search-toggle svg {
      width: 18px;
      height: 18px;
      stroke: rgba(255, 255, 255, 0.5);
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
    #search-toggle:hover svg {
      stroke: rgba(255, 255, 255, 0.8);
    }

    /* Search panel */
    #search-panel {
      position: fixed;
      top: 0;
      right: 0;
      width: 340px;
      height: 100%;
      z-index: 160;
      background: rgba(5, 5, 7, 0.30);
      backdrop-filter: blur(24px) saturate(1.2);
      -webkit-backdrop-filter: blur(24px) saturate(1.2);
      border-left: 1px solid rgba(255, 255, 255, 0.08);
      transform: translateX(100%);
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      flex-direction: column;
      font-family: 'Courier New', 'Consolas', monospace;
      font-size: 12.5px;
      color: #ccc;
      box-shadow: -4px 0 30px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }
    #search-panel.open {
      transform: translateX(0);
    }
    #search-panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 18px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      flex-shrink: 0;
    }
    #search-panel-header span {
      font-size: 11px;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.35);
    }
    #search-close {
      background: none;
      border: none;
      color: rgba(255, 255, 255, 0.3);
      cursor: pointer;
      font-size: 18px;
      padding: 0 4px;
      line-height: 1;
      transition: color 0.2s;
    }
    #search-close:hover {
      color: rgba(255, 255, 255, 0.7);
    }
    #search-input-wrap {
      padding: 12px 18px;
      flex-shrink: 0;
    }
    #search-input {
      width: 100%;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      padding: 9px 12px;
      color: #eee;
      font-family: 'Courier New', 'Consolas', monospace;
      font-size: 13px;
      outline: none;
      transition: border-color 0.2s;
    }
    #search-input::placeholder {
      color: rgba(255, 255, 255, 0.2);
    }
    #search-input:focus {
      border-color: rgba(255, 255, 255, 0.2);
    }
    #search-presets {
      padding: 4px 18px 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      flex-shrink: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.04);
    }
    #search-presets:empty {
      display: none;
    }
    .search-preset {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.07);
      border-radius: 12px;
      padding: 4px 10px;
      font-family: 'Courier New', 'Consolas', monospace;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.35);
      cursor: pointer;
      transition: color 0.15s, border-color 0.15s, background 0.15s;
      white-space: nowrap;
    }
    .search-preset:hover {
      color: rgba(255, 255, 255, 0.6);
      border-color: rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.05);
    }
    .search-preset.active {
      color: rgba(255, 180, 120, 0.8);
      border-color: rgba(255, 180, 120, 0.2);
      background: rgba(255, 180, 120, 0.06);
    }
    #search-results {
      flex: 1;
      overflow-y: auto;
      padding: 4px 0;
      scrollbar-width: thin;
      scrollbar-color: rgba(255,255,255,0.08) transparent;
    }
    #search-results::-webkit-scrollbar {
      width: 4px;
    }
    #search-results::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.08);
      border-radius: 2px;
    }
    .search-section-label {
      font-size: 10px;
      letter-spacing: 1.5px;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.2);
      padding: 10px 18px 4px;
    }
    .search-row {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 7px 18px;
      cursor: pointer;
      transition: background 0.15s;
      user-select: none;
    }
    .search-row:hover {
      background: rgba(255, 255, 255, 0.04);
    }
    .search-row.selected {
      background: rgba(255, 255, 255, 0.06);
    }
    .search-row-check {
      width: 14px;
      height: 14px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 3px;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, border-color 0.15s;
    }
    .search-row.selected .search-row-check {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .search-row.selected .search-row-check::after {
      content: '';
      width: 6px;
      height: 6px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 1px;
    }
    .search-row-name {
      flex: 1;
      color: rgba(255, 255, 255, 0.65);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .search-row.selected .search-row-name {
      color: rgba(255, 255, 255, 0.9);
    }
    .search-row-tag {
      font-size: 9px;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 3px;
      flex-shrink: 0;
    }
    .search-row-tag.tag-F {
      color: rgba(255, 180, 120, 0.7);
      background: rgba(255, 180, 120, 0.08);
    }
    .search-row-tag.tag-B {
      color: rgba(120, 180, 255, 0.7);
      background: rgba(120, 180, 255, 0.08);
    }
    .search-row-tag.tag-L {
      color: rgba(180, 255, 160, 0.6);
      background: rgba(180, 255, 160, 0.06);
    }
    .search-stats {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.25);
      padding: 4px 18px 8px 44px;
      line-height: 1.5;
    }
    #search-clear-all {
      flex-shrink: 0;
      padding: 12px 18px;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      text-align: center;
    }
    #search-clear-btn {
      background: none;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      color: rgba(255, 255, 255, 0.3);
      font-family: 'Courier New', 'Consolas', monospace;
      font-size: 11px;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 7px 20px;
      cursor: pointer;
      transition: color 0.2s, border-color 0.2s;
    }
    #search-clear-btn:hover {
      color: rgba(255, 255, 255, 0.6);
      border-color: rgba(255, 255, 255, 0.15);
    }

    /* Mobile: keep title left-aligned but compact so graph is visible */
    @media (max-width: 768px) {
      #hero {
        padding-left: 24px;
        padding-right: 24px;
        justify-content: flex-end;
        padding-bottom: 140px;
      }
      #hero-title {
        font-size: 36px;
      }
      #hero-subtitle {
        font-size: 11px;
        letter-spacing: 2px;
        margin-top: 10px;
      }
      #content-inner {
        padding-top: 80px;
        padding-bottom: 80px;
      }
      #graph-info-box {
        max-width: 320px;
        min-width: 260px;
        font-size: 11.5px;
      }
      #graph-label {
        display: none;
      }
      #scroll-indicator {
        bottom: 60px;
      }
      #tooltip {
        max-width: calc(100vw - 32px);
        min-width: 0;
        padding: 10px 14px;
        font-size: 11.5px;
        line-height: 1.5;
      }
      .tt-header {
        font-size: 12.5px;
        letter-spacing: 1px;
      }
      .tt-label {
        min-width: 64px;
      }
      #search-panel {
        width: 100%;
      }
      #search-toggle {
        top: 12px;
        right: 12px;
        width: 36px;
        height: 36px;
      }
    }
  </style>
</head>
<body>

  <!-- Fixed graph background -->
  <div id="graph-container"></div>

  <!-- Hero overlay -->
  <div id="hero">
    <div id="hero-title">Phaistos Labs</div>
    <div id="hero-subtitle"><span id="typewriter"></span><span id="typewriter-cursor">|</span></div>
    <div id="scroll-indicator">
      <span>Scroll</span>
      <div class="chevron"></div>
    </div>
  </div>

  <!-- Shimmer label on graph -->
  <div id="graph-label" onclick="document.getElementById('graph-info').style.display='flex'">Learn more about this graph</div>

  <!-- Graph info popup -->
  <div id="graph-info" onclick="if(event.target===this)this.style.display='none'">
    <div id="graph-info-box">
      <div class="tt-header">World Language Phylogenetic Graph</div>
      <div class="tt-row"><span class="tt-label">Nodes</span><span class="tt-value">1,926 languages across 88 families</span></div>
      <div class="tt-row"><span class="tt-label">Edges</span><span class="tt-value">1,830 parent–child phylogenetic links</span></div>
      <div class="tt-row"><span class="tt-label">Data</span><span class="tt-value">Every major language family, living and extinct</span></div>
      <div class="tt-row" style="margin-top:8px"><span class="tt-value" style="color:rgba(255,255,255,0.45)">Each node represents a language, sized by the number of descendant languages in its branch. Edges trace phylogenetic descent from proto-languages to their modern offspring. Families are loosely clustered and colour-coded by warm hue. Click any node to inspect it.</span></div>
      <div style="margin-top:10px;font-size:11px;color:rgba(255,255,255,0.2);letter-spacing:1px;text-align:right;cursor:pointer" onclick="document.getElementById('graph-info').style.display='none'">CLOSE</div>
    </div>
  </div>

  <!-- Content below the fold -->
  <div id="content">
    <div id="content-inner">
      <h2>Our Mission</h2>
      <p>Phaistos Labs is building computational infrastructure to decipher Minoan Linear A, one of the last undeciphered writing systems of the ancient Mediterranean. Our approach combines constructed phonetic analysis with advanced phylogenetic language tree models to systematically reconstruct the sound values of Linear A signs.</p>
      <p>By computationally mapping phonetic evolutionary pathways across Bronze Age language families, we construct probabilistic models of how sound systems shifted from known ancestor languages into the Minoan substrate. These models generate candidate phonetic readings for Linear A sequences, which we then validate by searching for statistically significant cognate matches against vocabularies of attested contemporary and descendant languages.</p>
      <p>Each confirmed cognate serves as a beachhead &mdash; a fixed point from which we expand our phonetic grid outward, constraining the remaining sign values and progressively narrowing the solution space. Through iterative refinement of these phylogenetic mappings and cross-validation against independent epigraphic evidence, we aim to achieve the first systematic, reproducible decipherment of Linear A.</p>
      <div class="contact">For more information, reach out to <a href="mailto:alvinxyz@stanford.edu">alvinxyz@stanford.edu</a></div>
    </div>
  </div>

  <div id="tooltip"></div>
  <div id="leader-labels"></div>

  <button id="search-toggle" title="Search languages (Ctrl+K)">
    <svg viewBox="0 0 24 24"><circle cx="11" cy="11" r="7"/><line x1="16.5" y1="16.5" x2="21" y2="21"/></svg>
  </button>

  <div id="search-panel">
    <div id="search-panel-header">
      <span>Search Languages</span>
      <button id="search-close">&times;</button>
    </div>
    <div id="search-input-wrap">
      <input id="search-input" type="text" placeholder="Type to search..." autocomplete="off" spellcheck="false" />
    </div>
    <div id="search-presets"></div>
    <div id="search-results"></div>
    <div id="search-clear-all">
      <button id="search-clear-btn">Clear All</button>
    </div>
  </div>

  <!-- Scroll-based transitions -->
  <script>
    // Hero fade/scale on scroll AND on zoom
    const hero = document.getElementById('hero');
    const heroTitle = document.getElementById('hero-title');
    const heroSubtitle = document.getElementById('hero-subtitle');
    const scrollIndicator = document.getElementById('scroll-indicator');
    const graphLabel = document.getElementById('graph-label');

    // Content reveal on scroll
    const revealEls = document.querySelectorAll('#content-inner h2, #content-inner p, #content-inner .contact');

    // Expose zoom state for the scroll handler (set by Three.js module)
    window._graphZoom = { target: window.innerWidth <= 768 ? 3400 : 2800, base: window.innerWidth <= 768 ? 3400 : 2800 };

    function onScroll() {
      const scrollY = window.scrollY;
      const vh = window.innerHeight;

      // Scroll-based fade
      const scrollProgress = Math.min(1, scrollY / (vh * 0.45));

      // Zoom-based fade: 0 at base zoom, 1 when zoomed in significantly
      const zoomDelta = window._graphZoom.base - window._graphZoom.target;
      const zoomProgress = Math.min(1, Math.max(0, zoomDelta / 800));

      // Combined: whichever is stronger hides the hero
      const heroProgress = Math.max(scrollProgress, zoomProgress);
      const heroOpacity = 1 - heroProgress;
      const heroScale = 1 + heroProgress * 0.08;
      heroTitle.style.opacity = heroOpacity;
      heroTitle.style.transform = `scale(${heroScale})`;
      heroSubtitle.style.opacity = heroOpacity * 0.8;
      heroSubtitle.style.transform = `scale(${heroScale * 0.995})`;
      // Scroll indicator: fade out when scrolling toward content, reappear when back at graph
      const scrolledToContent = scrollY > vh * 0.25;
      if (scrolledToContent) {
        scrollIndicator.style.opacity = '0';
      } else {
        scrollIndicator.style.opacity = Math.max(0, 0.35 - heroProgress * 1.5);
      }
      graphLabel.style.opacity = Math.max(0, 1 - heroProgress * 3);

      // Content: reveal elements as they enter viewport
      revealEls.forEach((el, i) => {
        const rect = el.getBoundingClientRect();
        if (rect.top < vh * 0.85) {
          setTimeout(() => el.classList.add('visible'), i * 80);
        }
      });
    }

    window.addEventListener('scroll', onScroll, { passive: true });
    // Also run on every animation frame to catch zoom changes
    (function tickHero() { onScroll(); requestAnimationFrame(tickHero); })();

    // Typewriter animation
    (function typewriter() {
      const text = 'Deciphering the world\'s lost languages';
      const el = document.getElementById('typewriter');
      const cursor = document.getElementById('typewriter-cursor');
      let started = false;
      let i = 0;
      const speed = 25; // ms per character
      function type() {
        if (i < text.length) {
          el.textContent += text.charAt(i);
          i++;
          setTimeout(type, speed + Math.random() * 30);
        } else {
          setTimeout(() => { cursor.style.display = 'none'; }, 1500);
        }
      }
      // Graph module can trigger this early; otherwise fallback at 800ms
      window._startTypewriter = function() { if (!started) { started = true; type(); } };
      setTimeout(window._startTypewriter, 800);
    })();
  </script>
  <script src="language_data.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

    // ================================================================
    // LOAD AND PROCESS LANGUAGE DATA
    // ================================================================
    const raw = window.LANGUAGE_DATA;
    const nodeMap = new Map();
    raw.nodes.forEach(n => nodeMap.set(n.id, n));

    // Count descendants for each node (recursive)
    const descendantCount = new Map();
    const childrenMap = new Map();
    raw.nodes.forEach(n => childrenMap.set(n.id, []));
    raw.edges.forEach(e => {
      const kids = childrenMap.get(e.source);
      if (kids) kids.push(e.target);
    });

    function countDescendants(id) {
      if (descendantCount.has(id)) return descendantCount.get(id);
      const kids = childrenMap.get(id) || [];
      let count = 0;
      for (const kid of kids) {
        count += 1 + countDescendants(kid);
      }
      descendantCount.set(id, count);
      return count;
    }
    raw.nodes.forEach(n => countDescendants(n.id));

    // Find all unique families for color assignment
    const families = [...new Set(raw.nodes.map(n => n.family))];

    // Family color palette — assign distinct hues, warm tones
    const FAMILY_COLORS = {};
    const MAJOR_FAMILY_COLORS = {
      'Indo-European': [0.0, 0.85, 0.55],    // red
      'Sino-Tibetan': [0.10, 0.9, 0.5],      // orange
      'Niger-Congo': [0.93, 0.85, 0.5],       // magenta-red
      'Afroasiatic': [0.06, 0.82, 0.55],      // red-orange
      'Austronesian': [0.14, 0.85, 0.48],     // amber
      'Dravidian': [0.02, 0.78, 0.5],         // deep red
      'Turkic': [0.08, 0.82, 0.45],           // warm orange
      'Uralic': [0.96, 0.72, 0.55],           // rose
      'Nilo-Saharan': [0.04, 0.9, 0.45],      // scarlet
      'Kra-Dai': [0.12, 0.85, 0.48],          // amber-gold
      'Austroasiatic': [0.07, 0.8, 0.52],      // orange
      'Algic': [0.90, 0.78, 0.5],             // pink
      'Na-Dene': [0.88, 0.8, 0.48],           // deep pink
      'Uto-Aztecan': [0.05, 0.88, 0.48],      // scarlet
      'Mayan': [0.11, 0.9, 0.46],             // amber
      'Tupian': [0.01, 0.85, 0.44],            // crimson
      'Quechuan': [0.03, 0.85, 0.52],          // warm red
      'Mongolic': [0.09, 0.72, 0.5],           // orange
      'Japonic': [0.97, 0.85, 0.55],           // rose-red
      'Koreanic': [0.95, 0.82, 0.52],          // pink-rose
    };

    families.forEach((fam, i) => {
      if (MAJOR_FAMILY_COLORS[fam]) {
        FAMILY_COLORS[fam] = MAJOR_FAMILY_COLORS[fam];
      } else {
        // Distribute remaining families across warm hue range
        const hue = (i * 0.618033988749895) % 1; // golden ratio distribution
        // Keep hues in the warm range (red-orange-pink: 0.9-0.15 wrapping)
        const warmHue = ((hue * 0.25) + 0.9) % 1;
        FAMILY_COLORS[fam] = [warmHue, 0.7 + Math.random() * 0.2, 0.4 + Math.random() * 0.15];
      }
    });

    // ================================================================
    // BUILD GRAPH DATA
    // ================================================================
    const SPREAD = 1200;
    const NODE_COUNT = raw.nodes.length;

    const graphData = {
      nodes: raw.nodes.map((n, i) => {
        const desc = descendantCount.get(n.id) || 0;
        const speakers = n.speakers || 0;
        // Experience: based on descendant count (more descendants = larger node)
        const experience = Math.min(1, desc / 80);
        // Recency: based on speaker count (more speakers = brighter)
        const recency = speakers > 0 ? Math.min(1, 0.3 + Math.log10(Math.max(1, speakers)) / 10) : 0.1;

        return {
          ...n,
          index: i,
          descendantCount: desc,
          experience,
          recency,
          position: new THREE.Vector3(
            (Math.random() - 0.5) * SPREAD,
            (Math.random() - 0.5) * SPREAD,
            (Math.random() - 0.5) * SPREAD
          ),
          velocity: new THREE.Vector3(),
          cascadeRevealTime: Infinity,
        };
      }),
      edges: raw.edges.map(e => {
        const si = raw.nodes.findIndex(n => n.id === e.source);
        const ti = raw.nodes.findIndex(n => n.id === e.target);
        return {
          sourceIdx: si,
          targetIdx: ti,
          source: e.source,
          target: e.target,
          phaseOffset: Math.random() * Math.PI * 2,
          fiberSpeed: 0.12 + Math.random() * 0.14,
          cascadeRevealTime: Infinity,
          cascadeDirection: 1,
        };
      }).filter(e => e.sourceIdx >= 0 && e.targetIdx >= 0),
      adjacency: [],
    };

    // Build adjacency
    graphData.adjacency = Array.from({ length: NODE_COUNT }, () => []);
    for (let ei = 0; ei < graphData.edges.length; ei++) {
      graphData.adjacency[graphData.edges[ei].sourceIdx].push(ei);
      graphData.adjacency[graphData.edges[ei].targetIdx].push(ei);
    }

    // ================================================================
    // CONFIGURATION
    // ================================================================
    const SEGMENTS_PER_EDGE = 12;
    const COLOR_CREAM = new THREE.Color('#fff5e6');

    // Cascade cycle timing
    const CASCADE_DUR = 10;
    const SETTLE_DUR = 1.5;
    const STEADY_DUR = 12;
    const FADEOUT_DUR = 1.5;
    const DARK_DUR = 0.3;
    const WAVE_INTERVAL = 0.3;
    const INTRA_WAVE_DELAY = 0.008;
    const EDGE_GROW_DUR = 0.8;

    // ================================================================
    // FORCE-DIRECTED LAYOUT (pre-compute)
    // ================================================================
    // For 1900+ nodes, O(n^2) is too slow. Use grid-based approximation.
    const GRID_SIZE = 8;
    const REPULSION = 6000;
    const SPRING_K = 0.008;
    const REST_LEN = 15;
    const DAMPING = 0.85;
    const CENTER_PULL = 0.002;
    const _diff = new THREE.Vector3();

    // Group nodes by family for initial positioning — cluster families together
    const familyGroups = new Map();
    graphData.nodes.forEach((n, i) => {
      if (!familyGroups.has(n.family)) familyGroups.set(n.family, []);
      familyGroups.get(n.family).push(i);
    });

    // Initial positions: randomized galaxy-like scatter with loose family clustering
    // Box-Muller transform for Gaussian random numbers
    function gaussRand() {
      let u = 0, v = 0;
      while (u === 0) u = Math.random();
      while (v === 0) v = Math.random();
      return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    }
    const famRadius = SPREAD * 0.4;
    familyGroups.forEach((indices, family) => {
      // Random direction for family center with Gaussian radial scatter
      const theta = Math.random() * Math.PI * 2;
      const cosP = 2 * Math.random() - 1;
      const sinP = Math.sqrt(1 - cosP * cosP);
      const rFam = famRadius * (0.3 + 0.7 * Math.random()); // radial jitter
      const cx = rFam * sinP * Math.cos(theta);
      const cy = rFam * sinP * Math.sin(theta);
      const cz = rFam * cosP;

      // Scatter languages within the family cluster using Gaussian offsets
      const clusterRadius = Math.min(SPREAD * 0.3, 30 + indices.length * 1.5);
      indices.forEach((ni) => {
        const node = graphData.nodes[ni];
        const ox = gaussRand() * clusterRadius * 0.4;
        const oy = gaussRand() * clusterRadius * 0.4;
        const oz = gaussRand() * clusterRadius * 0.4;
        node.position.set(cx + ox, cy + oy, cz + oz);
      });
    });

    // Grid-accelerated force simulation
    function simulateForces() {
      const ns = graphData.nodes;
      const gridCells = new Map();
      const cellSize = SPREAD / GRID_SIZE;

      // Build spatial grid
      for (let i = 0; i < NODE_COUNT; i++) {
        const p = ns[i].position;
        const gx = Math.floor(p.x / cellSize);
        const gy = Math.floor(p.y / cellSize);
        const gz = Math.floor(p.z / cellSize);
        const key = `${gx},${gy},${gz}`;
        if (!gridCells.has(key)) gridCells.set(key, []);
        gridCells.get(key).push(i);
      }

      // Repulsion — only between nearby cells
      for (const [key, cell] of gridCells) {
        const [gx, gy, gz] = key.split(',').map(Number);
        // Check neighboring cells
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            for (let dz = -1; dz <= 1; dz++) {
              const nkey = `${gx+dx},${gy+dy},${gz+dz}`;
              const ncell = gridCells.get(nkey);
              if (!ncell) continue;
              for (const i of cell) {
                for (const j of ncell) {
                  if (j <= i) continue;
                  _diff.subVectors(ns[i].position, ns[j].position);
                  const dist = Math.max(_diff.length(), 1);
                  if (dist > cellSize * 3) continue;
                  const f = REPULSION / (dist * dist);
                  _diff.normalize().multiplyScalar(Math.min(f, 5));
                  ns[i].velocity.add(_diff);
                  ns[j].velocity.sub(_diff);
                }
              }
            }
          }
        }
      }

      // Spring attraction along edges
      for (const e of graphData.edges) {
        const a = ns[e.sourceIdx];
        const b = ns[e.targetIdx];
        _diff.subVectors(b.position, a.position);
        const d = _diff.length();
        _diff.normalize().multiplyScalar(SPRING_K * (d - REST_LEN));
        a.velocity.add(_diff);
        b.velocity.sub(_diff);
      }

      // Centering + damping
      for (const n of ns) {
        n.velocity.add(n.position.clone().multiplyScalar(-CENTER_PULL));
        n.velocity.multiplyScalar(DAMPING);
        // Clamp velocity
        const speed = n.velocity.length();
        if (speed > 10) n.velocity.multiplyScalar(10 / speed);
        n.position.add(n.velocity);
      }
    }

    console.log('Running force layout...');
    for (let i = 0; i < 80; i++) simulateForces();
    console.log('Layout complete.');

    // ================================================================
    // SEARCH INDEX + FUZZY SEARCH
    // ================================================================
    const searchIndex = [];
    // Add languages
    graphData.nodes.forEach((n, i) => {
      searchIndex.push({
        name: n.name,
        type: 'language',
        family: n.family,
        branch: n.branch,
        nodeIndex: i,
      });
    });
    // Add unique families
    const seenFamilies = new Set();
    graphData.nodes.forEach(n => {
      if (!seenFamilies.has(n.family)) {
        seenFamilies.add(n.family);
        searchIndex.push({ name: n.family, type: 'family', family: n.family, branch: null, nodeIndex: -1 });
      }
    });
    // Add unique branches
    const seenBranches = new Set();
    graphData.nodes.forEach(n => {
      if (n.branch && !seenBranches.has(n.branch)) {
        seenBranches.add(n.branch);
        searchIndex.push({ name: n.branch, type: 'branch', family: n.family, branch: n.branch, nodeIndex: -1 });
      }
    });

    function bigrams(s) {
      const b = new Set();
      const lc = s.toLowerCase();
      for (let i = 0; i < lc.length - 1; i++) b.add(lc.slice(i, i + 2));
      return b;
    }

    function diceCoefficient(a, b) {
      const ba = bigrams(a);
      const bb = bigrams(b);
      if (ba.size === 0 && bb.size === 0) return 1;
      if (ba.size === 0 || bb.size === 0) return 0;
      let intersection = 0;
      for (const bg of ba) if (bb.has(bg)) intersection++;
      return (2 * intersection) / (ba.size + bb.size);
    }

    function combinedScore(query, target) {
      const q = query.toLowerCase();
      const t = target.toLowerCase();
      if (q === t) return 1.0;
      if (t.startsWith(q)) return 0.95;
      // Word boundary match (e.g. "germ" matches "Proto-Germanic" at "Germanic")
      const words = t.split(/[\s\-_]+/);
      for (const w of words) {
        if (w.startsWith(q)) return 0.88;
      }
      if (t.includes(q)) return 0.85;
      return diceCoefficient(q, t);
    }

    function fuzzySearch(query, maxResults = 10) {
      if (!query || query.length === 0) return [];
      const scored = searchIndex.map(entry => ({
        entry,
        score: combinedScore(query, entry.name),
      })).filter(s => s.score > 0.25);
      // Sort: score desc, then type priority (family > branch > language), then name asc
      const typePriority = { family: 0, branch: 1, language: 2 };
      scored.sort((a, b) => {
        if (Math.abs(b.score - a.score) > 0.001) return b.score - a.score;
        const tp = (typePriority[a.entry.type] || 2) - (typePriority[b.entry.type] || 2);
        if (tp !== 0) return tp;
        return a.entry.name.localeCompare(b.entry.name);
      });
      return scored.slice(0, maxResults).map(s => s.entry);
    }

    // ================================================================
    // SEARCH PANEL UI
    // ================================================================
    const searchPanel = document.getElementById('search-panel');
    const searchToggle = document.getElementById('search-toggle');
    const searchClose = document.getElementById('search-close');
    const searchInput = document.getElementById('search-input');
    const searchResultsEl = document.getElementById('search-results');
    const searchClearBtn = document.getElementById('search-clear-btn');
    const searchSelections = new Map(); // key -> entry

    let searchActive = false;
    let searchHighlightedNodes = new Set();
    let searchHighlightedEdges = new Set();
    let searchCascadeTime = 0;

    function openSearchPanel() {
      searchPanel.classList.add('open');
      searchToggle.style.opacity = '0';
      searchToggle.style.pointerEvents = 'none';
      setTimeout(() => searchInput.focus(), 300);
    }

    function closeSearchPanel() {
      searchPanel.classList.remove('open');
      searchToggle.style.opacity = '';
      searchToggle.style.pointerEvents = '';
      searchInput.blur();
    }

    searchToggle.addEventListener('click', (e) => {
      e.stopPropagation();
      openSearchPanel();
    });
    searchClose.addEventListener('click', () => closeSearchPanel());

    // Prevent graph interaction through panel
    searchPanel.addEventListener('mousedown', (e) => e.stopPropagation());
    searchPanel.addEventListener('click', (e) => e.stopPropagation());
    searchPanel.addEventListener('wheel', (e) => e.stopPropagation());
    searchPanel.addEventListener('touchstart', (e) => e.stopPropagation());
    searchPanel.addEventListener('touchmove', (e) => e.stopPropagation());

    // Keyboard shortcuts
    window.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && searchPanel.classList.contains('open')) {
        closeSearchPanel();
        e.preventDefault();
      }
      if ((e.key === '/' || (e.key === 'k' && (e.ctrlKey || e.metaKey))) && !searchPanel.classList.contains('open')) {
        // Don't open if user is typing in some other input
        if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) return;
        e.preventDefault();
        openSearchPanel();
      }
    });

    // Search input handler
    searchInput.addEventListener('input', () => {
      renderSearchResults();
    });

    searchClearBtn.addEventListener('click', () => {
      searchSelections.clear();
      searchInput.value = '';
      renderSearchResults();
      renderPresets();
      applySearchHighlighting();
    });

    function getNodeIndicesForSelection(sel) {
      const indices = new Set();
      if (sel.type === 'family') {
        const famNodes = familyGroups.get(sel.family);
        if (famNodes) famNodes.forEach(i => indices.add(i));
      } else if (sel.type === 'branch') {
        // Include all nodes whose branch matches or is a sub-branch (separator is ' > ')
        graphData.nodes.forEach((n, i) => {
          if (n.branch && (n.branch === sel.branch || n.branch.startsWith(sel.branch + ' > '))) {
            indices.add(i);
          }
        });
      } else if (sel.type === 'language') {
        // The node itself + all descendants via BFS through edges (parent->child)
        indices.add(sel.nodeIndex);
        const queue = [sel.nodeIndex];
        const visited = new Set([sel.nodeIndex]);
        while (queue.length > 0) {
          const ni = queue.shift();
          const kids = childrenMap.get(graphData.nodes[ni].id);
          if (kids) {
            for (const kidId of kids) {
              const kidIdx = graphData.nodes.findIndex(n => n.id === kidId);
              if (kidIdx >= 0 && !visited.has(kidIdx)) {
                visited.add(kidIdx);
                indices.add(kidIdx);
                queue.push(kidIdx);
              }
            }
          }
        }
      }
      return indices;
    }

    function computeSelectionStats(nodeIndices) {
      let alive = 0, extinct = 0, moribund = 0, totalSpeakers = 0;
      const continents = new Set();
      for (const i of nodeIndices) {
        const n = graphData.nodes[i];
        if (n.status === 'alive') alive++;
        else if (n.status === 'extinct') extinct++;
        else if (n.status === 'moribund') moribund++;
        if (n.speakers) totalSpeakers += n.speakers;
        if (n.continent) continents.add(n.continent);
      }
      return { count: nodeIndices.size, alive, extinct, moribund, totalSpeakers, continents: [...continents] };
    }

    function renderSearchResults() {
      const query = searchInput.value.trim();
      let html = '';

      // Selected section
      if (searchSelections.size > 0) {
        html += '<div class="search-section-label">Selected</div>';
        for (const [key, sel] of searchSelections) {
          const tagClass = sel.type === 'family' ? 'tag-F' : sel.type === 'branch' ? 'tag-B' : 'tag-L';
          const tagLabel = sel.type === 'family' ? 'F' : sel.type === 'branch' ? 'B' : 'L';
          const nodeIndices = getNodeIndicesForSelection(sel);
          const stats = computeSelectionStats(nodeIndices);
          html += `<div class="search-row selected" data-key="${key}">`;
          html += `<div class="search-row-check"></div>`;
          html += `<span class="search-row-name">${sel.name}</span>`;
          html += `<span class="search-row-tag ${tagClass}">${tagLabel}</span>`;
          html += `</div>`;
          // Stats line
          const parts = [];
          parts.push(`${stats.count} lang${stats.count !== 1 ? 's' : ''}`);
          if (stats.alive > 0) parts.push(`${stats.alive} living`);
          if (stats.extinct > 0) parts.push(`${stats.extinct} extinct`);
          if (stats.moribund > 0) parts.push(`${stats.moribund} moribund`);
          if (stats.totalSpeakers > 0) parts.push(formatSpeakers(stats.totalSpeakers) + ' speakers');
          html += `<div class="search-stats">${parts.join(' / ')}</div>`;
        }
      }

      // Search results
      if (query.length > 0) {
        const results = fuzzySearch(query);
        if (results.length > 0) {
          html += '<div class="search-section-label">Results</div>';
          for (const entry of results) {
            const key = `${entry.type}:${entry.name}`;
            if (searchSelections.has(key)) continue; // already in selected
            const tagClass = entry.type === 'family' ? 'tag-F' : entry.type === 'branch' ? 'tag-B' : 'tag-L';
            const tagLabel = entry.type === 'family' ? 'F' : entry.type === 'branch' ? 'B' : 'L';
            html += `<div class="search-row" data-key="${key}">`;
            html += `<div class="search-row-check"></div>`;
            html += `<span class="search-row-name">${entry.name}</span>`;
            html += `<span class="search-row-tag ${tagClass}">${tagLabel}</span>`;
            html += `</div>`;
          }
        } else {
          html += '<div class="search-section-label" style="padding-top:20px;text-align:center">No matches</div>';
        }
      } else if (searchSelections.size === 0) {
        html += '<div class="search-section-label" style="padding-top:20px;text-align:center">Type to find families, branches, or languages</div>';
      }

      searchResultsEl.innerHTML = html;

      // Attach click handlers
      searchResultsEl.querySelectorAll('.search-row').forEach(row => {
        row.addEventListener('click', () => handleRowClick(row));
      });
    }

    let lastAddedSelectionKey = null; // track what was just added for incremental BFS

    function handleRowClick(row) {
      const key = row.dataset.key;
      if (searchSelections.has(key)) {
        // Deselect
        searchSelections.delete(key);
        lastAddedSelectionKey = null;
      } else {
        // Select — find the entry in searchIndex
        const [type, ...nameParts] = key.split(':');
        const name = nameParts.join(':');
        const entry = searchIndex.find(e => e.type === type && e.name === name);
        if (entry) {
          searchSelections.set(key, entry);
          lastAddedSelectionKey = key;
        }
      }
      renderSearchResults();
      renderPresets();
      applySearchHighlighting();
    }

    // ================================================================
    // SEARCH HIGHLIGHT / CASCADE
    // ================================================================
    function computeSearchSets() {
      searchHighlightedNodes = new Set();
      searchHighlightedEdges = new Set();
      for (const [, sel] of searchSelections) {
        const nodeIndices = getNodeIndicesForSelection(sel);
        for (const ni of nodeIndices) searchHighlightedNodes.add(ni);
      }
      // Edges where both endpoints are highlighted
      graphData.edges.forEach((e, ei) => {
        if (searchHighlightedNodes.has(e.sourceIdx) && searchHighlightedNodes.has(e.targetIdx)) {
          searchHighlightedEdges.add(ei);
        }
      });
    }

    function updateSearchDimAttribute() {
      const dimAttr = edgeGeo.getAttribute('aSearchDim');
      let vi = 0;
      for (let ei = 0; ei < graphData.edges.length; ei++) {
        const dimVal = searchActive && !searchHighlightedEdges.has(ei) ? 1.0 : 0.0;
        for (let s = 0; s < SEGMENTS_PER_EDGE; s++) {
          dimAttr.array[vi++] = dimVal;
          dimAttr.array[vi++] = dimVal;
        }
      }
      dimAttr.needsUpdate = true;
    }

    // Find a node in the already-lit set that connects to the new selection's nodes
    function findBridgeNode(newNodeSet) {
      // Look for edges that connect an already-lit node to a node in newNodeSet
      for (const ei of searchHighlightedEdges) {
        const e = graphData.edges[ei];
        if (newNodeSet.has(e.sourceIdx) && searchHighlightedNodes.has(e.targetIdx) && !newNodeSet.has(e.targetIdx)) {
          return e.sourceIdx; // start from the new side of the bridge
        }
        if (newNodeSet.has(e.targetIdx) && searchHighlightedNodes.has(e.sourceIdx) && !newNodeSet.has(e.sourceIdx)) {
          return e.targetIdx;
        }
      }
      // Check adjacency: any node in newNodeSet that has an edge to an already-revealed node
      const ns = graphData.nodes;
      for (const ni of newNodeSet) {
        for (const ei of graphData.adjacency[ni]) {
          const e = graphData.edges[ei];
          const other = e.sourceIdx === ni ? e.targetIdx : e.sourceIdx;
          if (searchHighlightedNodes.has(other) && !newNodeSet.has(other) && ns[other].cascadeRevealTime < 9000) {
            return ni;
          }
        }
      }
      return null;
    }

    function triggerSearchCascadeIncremental(addedKey) {
      const ns = graphData.nodes;
      const es = graphData.edges;
      const addedSel = searchSelections.get(addedKey);
      if (!addedSel) return;

      const newNodeIndices = getNodeIndicesForSelection(addedSel);
      if (newNodeIndices.size === 0) return;

      // Snapshot which nodes/edges are already lit BEFORE updating
      const previouslyLitNodes = new Set(searchHighlightedNodes);
      const previouslyLitEdges = new Set(searchHighlightedEdges);

      // Update the highlighted sets to include the new selection
      computeSearchSets();

      // Find a bridge node — a node in the new set adjacent to already-lit nodes
      const bridgeNode = findBridgeNode(newNodeIndices);

      // Only reset reveal times for NEW (not previously-lit) nodes/edges
      for (const ni of newNodeIndices) {
        if (!previouslyLitNodes.has(ni)) {
          ns[ni].cascadeRevealTime = Infinity;
        }
      }
      for (let ei = 0; ei < es.length; ei++) {
        const e = es[ei];
        if (!previouslyLitEdges.has(ei) && newNodeIndices.has(e.sourceIdx) && newNodeIndices.has(e.targetIdx)) {
          e.cascadeRevealTime = Infinity;
          e.cascadeDirection = 1;
        }
      }

      // Pick epicenter: bridge node if found, else centroid of new selection
      let epicenter;
      if (bridgeNode !== null) {
        epicenter = bridgeNode;
      } else {
        let cx = 0, cy = 0, cz = 0;
        for (const ni of newNodeIndices) { cx += ns[ni].position.x; cy += ns[ni].position.y; cz += ns[ni].position.z; }
        cx /= newNodeIndices.size; cy /= newNodeIndices.size; cz /= newNodeIndices.size;
        let bestDist = Infinity;
        epicenter = newNodeIndices.values().next().value;
        for (const ni of newNodeIndices) {
          const dx = ns[ni].position.x - cx, dy = ns[ni].position.y - cy, dz = ns[ni].position.z - cz;
          const d = dx * dx + dy * dy + dz * dz;
          if (d < bestDist) { bestDist = d; epicenter = ni; }
        }
      }

      // Run BFS for new nodes only, starting from current cascade time
      // Previous selections' reveal times are untouched — they continue at their own pace
      runBFS(epicenter, searchCascadeTime, newNodeIndices);

      // Non-selected still at 9999
      for (const n of ns) if (n.cascadeRevealTime === Infinity) n.cascadeRevealTime = 9999;
      for (const e of es) if (e.cascadeRevealTime === Infinity) e.cascadeRevealTime = 9999;

      updateEdgeAttributes();
    }

    function triggerSearchCascadeFull() {
      const ns = graphData.nodes;
      const es = graphData.edges;
      // Reset all reveal times
      for (const n of ns) n.cascadeRevealTime = Infinity;
      for (const e of es) { e.cascadeRevealTime = Infinity; e.cascadeDirection = 1; }

      // Run BFS for each selection with stagger
      let staggerOffset = 0;
      for (const [, sel] of searchSelections) {
        const nodeIndices = getNodeIndicesForSelection(sel);
        if (nodeIndices.size === 0) continue;

        const nodeSet = nodeIndices;
        let cx = 0, cy = 0, cz = 0;
        for (const ni of nodeSet) { cx += ns[ni].position.x; cy += ns[ni].position.y; cz += ns[ni].position.z; }
        cx /= nodeSet.size; cy /= nodeSet.size; cz /= nodeSet.size;
        let bestDist = Infinity, bestIdx = nodeSet.values().next().value;
        for (const ni of nodeSet) {
          const dx = ns[ni].position.x - cx, dy = ns[ni].position.y - cy, dz = ns[ni].position.z - cz;
          const d = dx * dx + dy * dy + dz * dz;
          if (d < bestDist) { bestDist = d; bestIdx = ni; }
        }
        runBFS(bestIdx, staggerOffset, nodeSet);
        staggerOffset += 0.5;
      }

      // Non-selected nodes/edges at 9999
      for (const n of ns) if (n.cascadeRevealTime === Infinity) n.cascadeRevealTime = 9999;
      for (const e of es) if (e.cascadeRevealTime === Infinity) e.cascadeRevealTime = 9999;

      updateEdgeAttributes();
      searchCascadeTime = 0;
    }

    function applySearchHighlighting() {
      if (searchSelections.size > 0) {
        const wasActive = searchActive;
        searchActive = true;

        if (wasActive && lastAddedSelectionKey && searchSelections.has(lastAddedSelectionKey)) {
          // Incremental add: just grow the new selection from existing lit nodes
          triggerSearchCascadeIncremental(lastAddedSelectionKey);
        } else if (wasActive && !lastAddedSelectionKey) {
          // Deselect: recompute sets and update dims, but don't restart cascade
          // Nodes that are no longer highlighted get pushed to 9999
          const prevNodes = new Set(searchHighlightedNodes);
          computeSearchSets();
          const ns = graphData.nodes;
          const es = graphData.edges;
          for (const ni of prevNodes) {
            if (!searchHighlightedNodes.has(ni)) ns[ni].cascadeRevealTime = 9999;
          }
          for (let ei = 0; ei < es.length; ei++) {
            const e = es[ei];
            if (!searchHighlightedEdges.has(ei) && e.cascadeRevealTime < 9000) {
              e.cascadeRevealTime = 9999;
            }
          }
          updateEdgeAttributes();
        } else {
          // First selection: full cascade
          computeSearchSets();
          triggerSearchCascadeFull();
        }
        updateSearchDimAttribute();
      } else {
        searchActive = false;
        searchHighlightedNodes.clear();
        searchHighlightedEdges.clear();
        updateSearchDimAttribute();
        // Resume normal cycle from steady phase
        phase = 'steady';
        phaseTime = 0;
        cascadeTime = 0;
        // Reset all to steady state
        const ns = graphData.nodes;
        const es = graphData.edges;
        for (const n of ns) n.cascadeRevealTime = 0;
        for (const e of es) { e.cascadeRevealTime = 0; e.cascadeDirection = 1; }
        updateEdgeAttributes();
      }
      lastAddedSelectionKey = null;
      syncLeaderLabels();
    }

    // ================================================================
    // LEADER-LINE LABELS
    // ================================================================
    const leaderLabels = new Map();       // selectionKey → label state
    const labelVisibility = new Map();    // selectionKey → boolean (user toggle)
    const leaderContainer = document.getElementById('leader-labels');
    const LABEL_ANIM_DUR = 0.4;
    const _projTmp = new THREE.Vector3();

    // Project all visible branch nodes to screen. Compute:
    //   - visible COM (center of mass of what the user can see)
    //   - radial direction outward from the projected GLOBE CENTER
    //     (geometrically correct at every zoom — the sphere center
    //      defines "outward" regardless of where it sits on screen)
    //   - visible radius along the radial (how far nodes extend)
    // The label line starts at the visible COM, extends radially
    // past the outermost visible node, then turns horizontal.
    function getSelectionScreenInfo(labelState) {
      const indices = labelState.nodeIndices;
      const W = window.innerWidth, H = window.innerHeight;

      // Project globe center (world origin through worldGroup transform)
      _projTmp.set(0, 0, 0);
      worldGroup.localToWorld(_projTmp);
      _projTmp.project(camera);
      const gcx = (_projTmp.x * 0.5 + 0.5) * W;
      const gcy = (-_projTmp.y * 0.5 + 0.5) * H;

      // Viewport bounds with padding (prevents pop-in during rotation)
      const vPad = 100;
      const vL = -vPad, vT = -vPad, vR = W + vPad, vB = H + vPad;

      // Project & filter to visible nodes
      const visible = [];
      for (const ni of indices) {
        nodeMeshes[ni].getWorldPosition(_projTmp);
        _projTmp.project(camera);
        if (_projTmp.z > 1) continue;
        const sx = (_projTmp.x * 0.5 + 0.5) * W;
        const sy = (-_projTmp.y * 0.5 + 0.5) * H;
        if (sx < vL || sx > vR || sy < vT || sy > vB) continue;
        visible.push({ sx, sy });
      }
      if (visible.length === 0) return null;

      // Visible center of mass
      let cx = 0, cy = 0;
      for (const p of visible) { cx += p.sx; cy += p.sy; }
      cx /= visible.length;
      cy /= visible.length;

      // Radial direction: globe center → visible COM (always outward from sphere)
      let rx = cx - gcx, ry = cy - gcy;
      const rLen = Math.hypot(rx, ry);
      if (rLen > 1) { rx /= rLen; ry /= rLen; }
      else { rx = 0; ry = -1; }

      // How far the visible cluster extends along the radial from its COM
      let maxRadial = 0;
      for (const p of visible) {
        const d = (p.sx - cx) * rx + (p.sy - cy) * ry;
        if (d > maxRadial) maxRadial = d;
      }

      return { cx, cy, rx, ry, visibleRadius: maxRadial };
    }

    function computeLabelGeometry(info, name) {
      const W = window.innerWidth;
      const H = window.innerHeight;
      const panelOpen = searchPanel.classList.contains('open');
      const isMobile = W <= 768;
      const panelW = (panelOpen && !isMobile) ? 340 : 0;
      const margin = isMobile ? 16 : 30;

      const { cx: anchorX, cy: anchorY, rx, ry, visibleRadius } = info;

      // Elbow sits just past the outermost visible node along the radial.
      // The diagonal adapts to the branch's visual size on screen.
      const pad = isMobile ? 15 : 25;
      const maxDiag = isMobile ? 120 : 200; // cap for very large families
      const elbowDist = Math.min(visibleRadius + pad, maxDiag);
      let elbowX = anchorX + rx * elbowDist;
      let elbowY = anchorY + ry * elbowDist;

      // Horizontal direction follows the radial's x component
      let dirX = rx >= 0 ? 1 : -1;

      // Text measurement
      const charW = isMobile ? 5 : 6.5;
      const textW = name.length * charW + 12;
      const horizLen = Math.max(isMobile ? 55 : 100, textW);

      let hx = elbowX + dirX * horizLen;

      // --- Boundary clamping ---
      const leftBound   = panelW + margin;
      const rightBound  = W - margin;
      const topBound    = margin;
      const bottomBound = H - margin;

      // If horizontal end goes off screen, flip dirX
      if (hx < leftBound || hx > rightBound) {
        dirX = -dirX;
        hx = elbowX + dirX * horizLen;
      }

      // Clamp elbow into viewport
      elbowX = Math.max(leftBound, Math.min(rightBound, elbowX));
      elbowY = Math.max(topBound, Math.min(bottomBound, elbowY));
      hx = Math.max(leftBound, Math.min(rightBound, hx));

      // If squeezed, try one more flip
      if (Math.abs(hx - elbowX) < 30) {
        dirX = -dirX;
        hx = elbowX + dirX * horizLen;
        hx = Math.max(leftBound, Math.min(rightBound, hx));
      }

      const points = `${anchorX},${anchorY} ${elbowX},${elbowY} ${hx},${elbowY}`;
      const seg1 = Math.hypot(elbowX - anchorX, elbowY - anchorY);
      const seg2 = Math.abs(hx - elbowX);
      const totalLength = seg1 + seg2;

      // Text clearly above the horizontal line
      const textX = Math.min(elbowX, hx) + 3;
      const textY = elbowY - (isMobile ? 12 : 15);

      return { points, totalLength, textX, textY, elbowY };
    }

    function createLeaderLabel(key, name, nodeIndices) {
      if (leaderLabels.has(key)) return;

      const container = document.createElement('div');
      container.className = 'leader-label';

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'leader-svg');
      svg.style.position = 'fixed';
      svg.style.top = '0';
      svg.style.left = '0';
      svg.style.width = '100%';
      svg.style.height = '100%';

      const polyline = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
      svg.appendChild(polyline);

      const textEl = document.createElement('div');
      textEl.className = 'leader-text';
      textEl.textContent = name;

      container.appendChild(svg);
      container.appendChild(textEl);
      leaderContainer.appendChild(container);

      const state = {
        key, name, nodeIndices: new Set(nodeIndices),
        phase: 'expanding', animT: 0,
        svgEl: svg, polylineEl: polyline, textEl, containerEl: container,
        totalLength: 0
      };
      leaderLabels.set(key, state);
      labelVisibility.set(key, true);
    }

    function removeLeaderLabel(key) {
      const state = leaderLabels.get(key);
      if (!state) return;
      if (state.phase === 'collapsing') return;
      state.phase = 'collapsing';
      state.animT = 1;
    }

    function destroyLeaderLabel(key) {
      const state = leaderLabels.get(key);
      if (!state) return;
      state.containerEl.remove();
      leaderLabels.delete(key);
    }

    function toggleLeaderLabel(key, name, nodeIndices) {
      const state = leaderLabels.get(key);
      if (state && (state.phase === 'visible' || state.phase === 'expanding')) {
        removeLeaderLabel(key);
        labelVisibility.set(key, false);
      } else if (!state || state.phase === 'collapsing') {
        if (state) destroyLeaderLabel(key); // destroy collapsing one to recreate
        createLeaderLabel(key, name, nodeIndices);
        labelVisibility.set(key, true);
      }
    }

    function syncLeaderLabels() {
      // Auto-show for language selections
      const activeKeys = new Set();
      for (const [key, sel] of searchSelections) {
        activeKeys.add(key);
        if (sel.type === 'language') {
          // Auto-show label for language selections
          if (!leaderLabels.has(key) && labelVisibility.get(key) !== false) {
            const nodeIndices = getNodeIndicesForSelection(sel);
            createLeaderLabel(key, sel.name, nodeIndices);
          }
        }
        // Family/branch: don't auto-show (they toggle on click)
      }

      // Collapse labels whose selection was removed
      for (const [key, state] of leaderLabels) {
        if (!activeKeys.has(key) && state.phase !== 'collapsing') {
          removeLeaderLabel(key);
        }
      }

      // If search is entirely cleared, collapse all and clear visibility
      if (searchSelections.size === 0) {
        for (const [key] of leaderLabels) {
          removeLeaderLabel(key);
        }
        labelVisibility.clear();
      }
    }

    function easeOutCubic(t) {
      return 1 - Math.pow(1 - t, 3);
    }

    function updateLeaderLabels(dt) {
      if (leaderLabels.size === 0) return;

      // Pass 1: advance animation + project visible nodes
      const candidates = [];
      for (const [key, state] of leaderLabels) {
        if (state.phase === 'expanding') {
          state.animT += dt / LABEL_ANIM_DUR;
          if (state.animT >= 1) { state.animT = 1; state.phase = 'visible'; }
        } else if (state.phase === 'collapsing') {
          state.animT -= dt / LABEL_ANIM_DUR;
          if (state.animT <= 0) { destroyLeaderLabel(key); continue; }
        }

        const info = getSelectionScreenInfo(state);
        if (!info) {
          state.containerEl.style.display = 'none';
          continue;
        }
        state.containerEl.style.display = '';
        candidates.push({ state, info });
      }

      // Pass 2: compute geometry (radial direction is baked into info)
      const labelPositions = [];
      for (const { state, info } of candidates) {
        const geo = computeLabelGeometry(info, state.name);
        state.totalLength = geo.totalLength;
        labelPositions.push({ state, geo, textY: geo.textY, textX: geo.textX });
      }

      // Pass 3: overlap avoidance — nudge labels too close vertically
      labelPositions.sort((a, b) => a.textY - b.textY);
      const minGap = 20;
      for (let i = 1; i < labelPositions.length; i++) {
        const prev = labelPositions[i - 1];
        const curr = labelPositions[i];
        if (Math.abs(curr.textX - prev.textX) < 160) {
          const gap = curr.textY - prev.textY;
          if (gap < minGap) {
            const nudge = (minGap - gap) / 2;
            prev.textY -= nudge;
            prev.geo.textY -= nudge;
            curr.textY += nudge;
            curr.geo.textY += nudge;
          }
        }
      }

      // Pass 4: apply to DOM
      for (const { state, geo } of labelPositions) {
        const easedT = easeOutCubic(state.animT);

        state.polylineEl.setAttribute('points', geo.points);
        state.polylineEl.setAttribute('stroke-dasharray', geo.totalLength);
        state.polylineEl.setAttribute('stroke-dashoffset', geo.totalLength - geo.totalLength * easedT);

        state.textEl.style.left = geo.textX + 'px';
        state.textEl.style.top = geo.textY + 'px';
        const textOpacity = Math.max(0, Math.min(1, (state.animT - 0.6) / 0.4));
        state.textEl.style.opacity = textOpacity;
      }
    }

    // Initialize search results view
    renderSearchResults();

    // Preset family suggestions — top 8 by node count
    const presetFamilies = [...familyGroups.entries()]
      .sort((a, b) => b[1].length - a[1].length)
      .slice(0, 8)
      .map(([name]) => name);

    const searchPresetsEl = document.getElementById('search-presets');

    function renderPresets() {
      searchPresetsEl.innerHTML = presetFamilies.map(fam => {
        const key = `family:${fam}`;
        const isActive = searchSelections.has(key);
        return `<button class="search-preset${isActive ? ' active' : ''}" data-family="${fam}">${fam}</button>`;
      }).join('');
      searchPresetsEl.querySelectorAll('.search-preset').forEach(btn => {
        btn.addEventListener('click', () => {
          const fam = btn.dataset.family;
          const key = `family:${fam}`;
          if (searchSelections.has(key)) {
            searchSelections.delete(key);
            lastAddedSelectionKey = null;
          } else {
            const entry = searchIndex.find(e => e.type === 'family' && e.name === fam);
            if (entry) {
              searchSelections.set(key, entry);
              lastAddedSelectionKey = key;
            }
          }
          renderPresets();
          renderSearchResults();
          applySearchHighlighting();
        });
      });
    }
    renderPresets();

    // ================================================================
    // BFS CASCADE
    // ================================================================
    function pickEpicenter() {
      const sorted = graphData.nodes
        .map((n, i) => ({ i, d: n.position.length() }))
        .sort((a, b) => a.d - b.d);
      const pool = sorted.slice(0, Math.floor(NODE_COUNT * 0.15));
      return pool[Math.floor(Math.random() * pool.length)].i;
    }

    // Run BFS cascade from a single epicenter (used for single-family cascades)
    function runBFS(epicenter, timeOffset, nodeSet, edgeFilter) {
      const ns = graphData.nodes;
      const es = graphData.edges;
      const adj = graphData.adjacency;
      const offset = timeOffset || 0;

      // If no nodeSet given, reset everything and cascade all
      if (!nodeSet) {
        for (const n of ns) n.cascadeRevealTime = Infinity;
        for (const e of es) { e.cascadeRevealTime = Infinity; e.cascadeDirection = 1; }
      }

      const visited = new Set();
      visited.add(epicenter);
      ns[epicenter].cascadeRevealTime = offset;

      let queue = [epicenter];
      let depth = 0;

      while (queue.length > 0) {
        const next = [];
        let intraIdx = 0;
        for (const nodeId of queue) {
          for (const ei of adj[nodeId]) {
            const e = es[ei];
            if (e.cascadeRevealTime < Infinity) continue;
            const other = e.sourceIdx === nodeId ? e.targetIdx : e.sourceIdx;
            if (nodeSet && !nodeSet.has(other)) continue; // stay within family

            e.cascadeRevealTime = offset + depth * WAVE_INTERVAL + intraIdx * INTRA_WAVE_DELAY;
            e.cascadeDirection = e.sourceIdx === nodeId ? 1 : -1;
            intraIdx++;

            if (!visited.has(other)) {
              visited.add(other);
              ns[other].cascadeRevealTime = e.cascadeRevealTime + EDGE_GROW_DUR * 0.4;
              next.push(other);
            }
          }
        }
        queue = next;
        depth++;
      }

      // Only fill in unreached nodes if doing a full (non-family) cascade
      if (!nodeSet) {
        const maxTime = offset + depth * WAVE_INTERVAL;
        for (const n of ns) if (n.cascadeRevealTime === Infinity) n.cascadeRevealTime = maxTime;
        for (const e of es) if (e.cascadeRevealTime === Infinity) e.cascadeRevealTime = maxTime;
      }
    }

    // Overlapping startup: next family begins well before the previous finishes
    const STARTUP_WAVE = 0.14;    // slow, visible BFS wave per depth level
    const STARTUP_GROW = 0.4;     // slow edge grow for smooth spread
    const OVERLAP_FRAC = 0.08;    // next family starts when previous is only 8% done
    function runStaggeredCascade() {
      const ns = graphData.nodes;
      const es = graphData.edges;
      const adj = graphData.adjacency;
      // Reset all
      for (const n of ns) n.cascadeRevealTime = Infinity;
      for (const e of es) { e.cascadeRevealTime = Infinity; e.cascadeDirection = 1; }

      // Shuffle families for random order
      const famKeys = [...familyGroups.keys()];
      for (let i = famKeys.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [famKeys[i], famKeys[j]] = [famKeys[j], famKeys[i]];
      }

      let runningOffset = 0;

      famKeys.forEach((fam) => {
        const indices = familyGroups.get(fam);
        if (!indices || indices.length === 0) return;
        const nodeSet = new Set(indices);
        const offset = runningOffset;

        // Pick epicenter near centroid
        let cx = 0, cy = 0, cz = 0;
        for (const ni of indices) { cx += ns[ni].position.x; cy += ns[ni].position.y; cz += ns[ni].position.z; }
        cx /= indices.length; cy /= indices.length; cz /= indices.length;
        let bestDist = Infinity, bestIdx = indices[0];
        for (const ni of indices) {
          const dx = ns[ni].position.x - cx, dy = ns[ni].position.y - cy, dz = ns[ni].position.z - cz;
          const d = dx*dx + dy*dy + dz*dz;
          if (d < bestDist) { bestDist = d; bestIdx = ni; }
        }

        // Inline BFS with startup timing
        const visited = new Set();
        visited.add(bestIdx);
        ns[bestIdx].cascadeRevealTime = Math.min(offset, ns[bestIdx].cascadeRevealTime);
        let queue = [bestIdx];
        let depth = 0;
        let famMaxTime = offset;
        while (queue.length > 0) {
          const next = [];
          let intraIdx = 0;
          for (const nodeId of queue) {
            for (const ei of adj[nodeId]) {
              const e = es[ei];
              const other = e.sourceIdx === nodeId ? e.targetIdx : e.sourceIdx;
              if (!nodeSet.has(other)) continue;
              const t = offset + depth * STARTUP_WAVE + intraIdx * 0.001;
              if (t >= e.cascadeRevealTime) continue; // already revealed earlier by another family
              e.cascadeRevealTime = t;
              e.cascadeDirection = e.sourceIdx === nodeId ? 1 : -1;
              if (t > famMaxTime) famMaxTime = t;
              intraIdx++;
              if (!visited.has(other)) {
                visited.add(other);
                const nt = t + STARTUP_GROW * 0.3;
                ns[other].cascadeRevealTime = Math.min(ns[other].cascadeRevealTime, nt);
                if (nt > famMaxTime) famMaxTime = nt;
                next.push(other);
              }
            }
          }
          queue = next;
          depth++;
        }

        // Next family starts when this one is ~30% through (overlap)
        const famDuration = famMaxTime - offset;
        runningOffset = offset + famDuration * OVERLAP_FRAC;
      });

      // Fill in any unreached nodes/edges
      let maxT = 0;
      for (const n of ns) if (n.cascadeRevealTime < Infinity && n.cascadeRevealTime > maxT) maxT = n.cascadeRevealTime;
      for (const n of ns) if (n.cascadeRevealTime === Infinity) n.cascadeRevealTime = maxT;
      for (const e of es) if (e.cascadeRevealTime === Infinity) e.cascadeRevealTime = maxT;
      startupCascadeDuration = maxT + STARTUP_GROW;
    }
    let startupCascadeDuration = 10; // will be set by runStaggeredCascade

    // ================================================================
    // THREE.JS SCENE
    // ================================================================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#000000');

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 20000);
    camera.position.set(0, 0, 2800);

    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    document.getElementById('graph-container').appendChild(renderer.domElement);

    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      2.8, 1.1, 0.05
    );
    composer.addPass(bloomPass);

    const worldGroup = new THREE.Group();
    scene.add(worldGroup);

    // ================================================================
    // NODE MESHES
    // ================================================================
    const nodeSphereGeo = new THREE.SphereGeometry(1, 12, 12);
    const nodeMeshes = [];

    for (const node of graphData.nodes) {
      const exp = node.experience;
      const rec = node.recency;
      const famColor = FAMILY_COLORS[node.family] || [0.0, 0.8, 0.5];

      const baseColor = new THREE.Color().setHSL(famColor[0], famColor[1], famColor[2]);
      baseColor.lerp(COLOR_CREAM, rec * 0.3 + exp * 0.15);
      const brightness = 0.65 + rec * 0.35;
      baseColor.multiplyScalar(brightness);

      // Size: descendant-based
      const size = 2.0 + Math.pow(exp, 1.2) * 14;

      const mat = new THREE.MeshBasicMaterial({
        color: baseColor,
        transparent: true,
        opacity: 0,
      });
      const mesh = new THREE.Mesh(nodeSphereGeo, mat);
      mesh.position.copy(node.position);
      mesh.scale.setScalar(size);
      mesh.userData = {
        baseSize: size,
        baseColor: baseColor.clone(),
        currentOpacity: 0,
        nodeIndex: node.index,
        langData: {
          id: node.id,
          name: node.name,
          family: node.family,
          branch: node.branch,
          status: node.status,
          speakers: node.speakers,
          continent: node.continent,
          depth: node.depth || 0,
          descendants: node.descendantCount,
        },
      };
      worldGroup.add(mesh);
      nodeMeshes.push(mesh);
    }

    // ================================================================
    // EDGE SHADER
    // ================================================================
    const edgeVS = `
      attribute float aPhaseOffset;
      attribute float aFiberSpeed;
      attribute float aEdgeProgress;
      attribute float aRevealTime;
      attribute float aDirection;
      attribute vec3 aColor;
      attribute float aSearchDim;

      uniform float uTime;
      uniform float uCascadeTime;
      uniform float uGrowDuration;
      uniform float uSteadyMix;
      uniform float uGlobalAlpha;
      uniform float uSearchMode;

      varying float vEdgeProgress;
      varying float vFiberAlpha;
      varying float vCascadeAlpha;
      varying float vSteadyMix;
      varying float vGlobalAlpha;
      varying float vPhaseOffset;
      varying float vFiberSpeed;
      varying vec3 vEdgeColor;
      varying float vSearchDim;

      void main() {
        vEdgeProgress = aEdgeProgress;
        vPhaseOffset = aPhaseOffset;
        vFiberSpeed = aFiberSpeed;
        vGlobalAlpha = uGlobalAlpha;
        vEdgeColor = aColor;
        vSearchDim = aSearchDim;

        // CASCADE GROW
        float cascadeElapsed = uCascadeTime - aRevealTime;
        float growFrac = clamp(cascadeElapsed / uGrowDuration, 0.0, 1.0);
        growFrac = 1.0 - pow(1.0 - growFrac, 2.5);
        float localProg = aDirection > 0.0 ? aEdgeProgress : 1.0 - aEdgeProgress;
        float visible = smoothstep(localProg - 0.01, localProg + 0.01, growFrac);
        float tipDist = growFrac - localProg;
        float tip = exp(-tipDist * tipDist * 300.0) * step(0.0, cascadeElapsed);
        vCascadeAlpha = cascadeElapsed >= 0.0 ? (visible * 0.28 + tip * 0.45) : 0.0;

        // Per-edge steady mix: in search mode, each edge independently transitions
        // from cascade glow to fiber-optic steady based on its own age
        if (uSearchMode > 0.5 && aRevealTime < 9000.0 && cascadeElapsed > 0.0) {
          float perEdgeSteady = clamp((cascadeElapsed - 5.0) / 1.5, 0.0, 1.0);
          perEdgeSteady = perEdgeSteady * perEdgeSteady * (3.0 - 2.0 * perEdgeSteady);
          vSteadyMix = max(uSteadyMix, perEdgeSteady);
        } else {
          vSteadyMix = uSteadyMix;
        }

        // FIBER OPTIC — two pulses
        float fiberPos1 = fract(uTime * aFiberSpeed + aPhaseOffset);
        float fiberPos2 = fract(uTime * aFiberSpeed + aPhaseOffset + 0.5);
        float d1a = abs(aEdgeProgress - fiberPos1);
        float d1 = min(d1a, 1.0 - d1a);
        float d2a = abs(aEdgeProgress - fiberPos2);
        float d2 = min(d2a, 1.0 - d2a);
        vFiberAlpha = max(exp(-d1 * d1 * 250.0), exp(-d2 * d2 * 250.0));

        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const edgeFS = `
      uniform float uTime;

      varying float vEdgeProgress;
      varying float vFiberAlpha;
      varying float vCascadeAlpha;
      varying float vSteadyMix;
      varying float vGlobalAlpha;
      varying vec3 vEdgeColor;
      varying float vSearchDim;

      void main() {
        float baseAlpha = 0.24;
        float fiberBoost = vFiberAlpha * 0.6;
        float steadyAlpha = baseAlpha + fiberBoost;

        vec3 steadyColor = vEdgeColor;
        steadyColor = mix(steadyColor, vec3(1.0, 0.88, 0.75), vFiberAlpha * 0.9);

        vec3 cascadeColor = vec3(0.95, 0.88, 0.8);

        // Fiber optic pulses on revealed cascade edges
        float revealFrac = smoothstep(0.1, 0.5, vCascadeAlpha);
        float fiberOnCascade = vFiberAlpha * 1.4 * revealFrac;
        float cascadeWithPulse = vCascadeAlpha + fiberOnCascade;
        vec3 cascadePulseColor = mix(cascadeColor, vec3(1.0, 0.98, 0.92), vFiberAlpha * revealFrac * 0.95);

        float alpha = mix(cascadeWithPulse, steadyAlpha, vSteadyMix) * vGlobalAlpha;
        vec3 color = mix(cascadePulseColor, steadyColor, vSteadyMix);

        // Search dimming: non-highlighted edges become invisible
        // Kill fiber pulse color too so bloom doesn't pick it up
        float searchKeep = 1.0 - vSearchDim;
        alpha *= searchKeep;
        color *= searchKeep;

        if (alpha < 0.001) discard;
        gl_FragColor = vec4(color, alpha);
      }
    `;

    // Build edge geometry
    const ePos = [], ePhase = [], eFiber = [], eProg = [], eReveal = [], eDir = [], eCol = [];
    const _tmpEdgeColor = new THREE.Color();

    for (const edge of graphData.edges) {
      const a = graphData.nodes[edge.sourceIdx].position;
      const b = graphData.nodes[edge.targetIdx].position;
      // Edge color from source node's family
      const srcFamily = graphData.nodes[edge.sourceIdx].family;
      const fc = FAMILY_COLORS[srcFamily] || [0.0, 0.8, 0.5];
      _tmpEdgeColor.setHSL(fc[0], fc[1], fc[2]);
      _tmpEdgeColor.multiplyScalar(0.55);
      for (let s = 0; s < SEGMENTS_PER_EDGE; s++) {
        const t0 = s / SEGMENTS_PER_EDGE;
        const t1 = (s + 1) / SEGMENTS_PER_EDGE;
        ePos.push(
          a.x+(b.x-a.x)*t0, a.y+(b.y-a.y)*t0, a.z+(b.z-a.z)*t0,
          a.x+(b.x-a.x)*t1, a.y+(b.y-a.y)*t1, a.z+(b.z-a.z)*t1
        );
        ePhase.push(edge.phaseOffset, edge.phaseOffset);
        eFiber.push(edge.fiberSpeed, edge.fiberSpeed);
        eProg.push(t0, t1);
        eReveal.push(edge.cascadeRevealTime, edge.cascadeRevealTime);
        eDir.push(edge.cascadeDirection, edge.cascadeDirection);
        eCol.push(_tmpEdgeColor.r, _tmpEdgeColor.g, _tmpEdgeColor.b,
                  _tmpEdgeColor.r, _tmpEdgeColor.g, _tmpEdgeColor.b);
      }
    }

    const edgeGeo = new THREE.BufferGeometry();
    edgeGeo.setAttribute('position',      new THREE.Float32BufferAttribute(ePos, 3));
    edgeGeo.setAttribute('aPhaseOffset',  new THREE.Float32BufferAttribute(ePhase, 1));
    edgeGeo.setAttribute('aFiberSpeed',   new THREE.Float32BufferAttribute(eFiber, 1));
    edgeGeo.setAttribute('aEdgeProgress', new THREE.Float32BufferAttribute(eProg, 1));
    edgeGeo.setAttribute('aRevealTime',   new THREE.Float32BufferAttribute(eReveal, 1));
    edgeGeo.setAttribute('aDirection',    new THREE.Float32BufferAttribute(eDir, 1));
    edgeGeo.setAttribute('aColor',        new THREE.Float32BufferAttribute(eCol, 3));
    const eSearchDim = new Float32Array(graphData.edges.length * SEGMENTS_PER_EDGE * 2);
    edgeGeo.setAttribute('aSearchDim',   new THREE.Float32BufferAttribute(eSearchDim, 1));
    const edgeMat = new THREE.ShaderMaterial({
      vertexShader: edgeVS,
      fragmentShader: edgeFS,
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime:         { value: 0 },
        uCascadeTime:  { value: 0 },
        uGrowDuration: { value: EDGE_GROW_DUR },
        uSteadyMix:    { value: 0 },
        uGlobalAlpha:  { value: 1 },
        uSearchMode:   { value: 0 },
      },
    });

    const edgeMesh = new THREE.LineSegments(edgeGeo, edgeMat);
    worldGroup.add(edgeMesh);

    // ================================================================
    // AMBIENT PARTICLES
    // ================================================================
    const particleCount = 350;
    const pPos = new Float32Array(particleCount * 3);
    const pColors = new Float32Array(particleCount * 3);
    for (let i = 0; i < particleCount; i++) {
      pPos[i*3]   = (Math.random()-0.5) * SPREAD * 4;
      pPos[i*3+1] = (Math.random()-0.5) * SPREAD * 4;
      pPos[i*3+2] = (Math.random()-0.5) * SPREAD * 4;
      const r = 0.3 + Math.random() * 0.4;
      pColors[i*3] = r; pColors[i*3+1] = r*0.15; pColors[i*3+2] = r*0.1;
    }
    const pGeo = new THREE.BufferGeometry();
    pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
    pGeo.setAttribute('color', new THREE.Float32BufferAttribute(pColors, 3));
    const pMat = new THREE.PointsMaterial({
      size: 2, transparent: true, opacity: 0.35,
      vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false,
    });
    worldGroup.add(new THREE.Points(pGeo, pMat));

    // ================================================================
    // CASCADE STATE MACHINE
    // ================================================================
    let phase = 'cascade';
    let phaseTime = 0;
    let cascadeTime = 0;
    let globalElapsed = 0;

    function updateEdgeAttributes() {
      const revealAttr = edgeGeo.getAttribute('aRevealTime');
      const dirAttr = edgeGeo.getAttribute('aDirection');
      let vi = 0;
      for (const edge of graphData.edges) {
        for (let s = 0; s < SEGMENTS_PER_EDGE; s++) {
          revealAttr.array[vi] = edge.cascadeRevealTime;
          dirAttr.array[vi] = edge.cascadeDirection;
          vi++;
          revealAttr.array[vi] = edge.cascadeRevealTime;
          dirAttr.array[vi] = edge.cascadeDirection;
          vi++;
        }
      }
      revealAttr.needsUpdate = true;
      dirAttr.needsUpdate = true;
    }

    // Startup: staggered cascade across all families
    runStaggeredCascade();
    updateEdgeAttributes();
    let isFirstCascade = true;
    let cascadeFamily = null; // null = all families (startup), string = single family

    function startNewCascade() {
      // Pick a random major family (with enough nodes to look good)
      const bigFamilies = [...familyGroups.entries()].filter(([, idx]) => idx.length >= 8);
      const [fam, indices] = bigFamilies[Math.floor(Math.random() * bigFamilies.length)];
      cascadeFamily = fam;

      const ns = graphData.nodes;
      const es = graphData.edges;
      // Reset all reveal times
      for (const n of ns) n.cascadeRevealTime = Infinity;
      for (const e of es) { e.cascadeRevealTime = Infinity; e.cascadeDirection = 1; }

      // BFS within this family only
      const nodeSet = new Set(indices);
      // Pick epicenter near centroid
      let cx = 0, cy = 0, cz = 0;
      for (const ni of indices) { cx += ns[ni].position.x; cy += ns[ni].position.y; cz += ns[ni].position.z; }
      cx /= indices.length; cy /= indices.length; cz /= indices.length;
      let bestDist = Infinity, bestIdx = indices[0];
      for (const ni of indices) {
        const dx = ns[ni].position.x - cx, dy = ns[ni].position.y - cy, dz = ns[ni].position.z - cz;
        const d = dx*dx + dy*dy + dz*dz;
        if (d < bestDist) { bestDist = d; bestIdx = ni; }
      }
      runBFS(bestIdx, 0, nodeSet);

      // Fill unreached within family; non-family edges stay at 9999 (never reached)
      let maxT = 0;
      for (const ni of indices) if (ns[ni].cascadeRevealTime < Infinity && ns[ni].cascadeRevealTime > maxT) maxT = ns[ni].cascadeRevealTime;
      for (const ni of indices) if (ns[ni].cascadeRevealTime === Infinity) ns[ni].cascadeRevealTime = maxT;
      for (const n of ns) if (n.cascadeRevealTime === Infinity) n.cascadeRevealTime = 9999;
      for (const e of es) if (e.cascadeRevealTime === Infinity) e.cascadeRevealTime = 9999;

      updateEdgeAttributes();
      cascadeTime = 0;
      isFirstCascade = false;
    }

    // ================================================================
    // MOUSE + ZOOM + DRAG
    // ================================================================
    const mouse = new THREE.Vector2(0, 0);
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let lastDragX = 0, lastDragY = 0;
    let isHoldingNode = false; // true when user is holding down on a node (pauses auto-rotation)

    // Quaternion-based rotation (avoids gimbal lock)
    const orientationQuat = new THREE.Quaternion();
    const _rotYAxis = new THREE.Vector3(0, 1, 0);
    const _rotXAxis = new THREE.Vector3(1, 0, 0);
    const _deltaQuat = new THREE.Quaternion();

    const graphEl = renderer.domElement;

    window.addEventListener('mousemove', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
      if (isDragging) {
        const dx = e.clientX - lastDragX;
        const dy = e.clientY - lastDragY;
        lastDragX = e.clientX;
        lastDragY = e.clientY;
        // Scale rotation sensitivity with zoom — slower when zoomed in for precision
        const rotScale = 0.004 * Math.max(0.25, camera.position.z / BASE_ZOOM);
        _deltaQuat.setFromAxisAngle(_rotYAxis, dx * rotScale);
        orientationQuat.premultiply(_deltaQuat);
        _deltaQuat.setFromAxisAngle(_rotXAxis, dy * rotScale);
        orientationQuat.premultiply(_deltaQuat);
      }
    });

    graphEl.addEventListener('mousedown', (e) => {
      isDragging = true;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      lastDragX = e.clientX;
      lastDragY = e.clientY;
      graphEl.style.cursor = 'grabbing';
      // Check if mousedown is on a node — if so, pause auto-rotation
      doRaycast(e.clientX, e.clientY);
      if (hoveredMesh) isHoldingNode = true;
    });

    window.addEventListener('mouseup', () => {
      isDragging = false;
      isHoldingNode = false;
      graphEl.style.cursor = hoveredMesh ? 'pointer' : 'grab';
    });

    graphEl.style.cursor = 'grab';

    // Prevent text selection on the graph area (fixes long-press text highlight on touch)
    graphEl.addEventListener('selectstart', (e) => e.preventDefault());

    const isMobile = window.innerWidth <= 768;
    const BASE_ZOOM = isMobile ? 3400 : 2800;
    let targetZoom = BASE_ZOOM;
    const ZOOM_MIN = 150;
    const ZOOM_MAX = 8000;

    // Directional zoom: camera offsets toward the zoom focus point
    let targetCamX = 0, targetCamY = 0;
    const zoomFocus = new THREE.Vector2(0, 0); // NDC of zoom target (-1 to 1)

    // Wheel: zoom graph when in hero view; bridge zoom-out to page scroll only at default zoom
    window.addEventListener('wheel', (e) => {
      // If already scrolled past hero, let the page scroll normally
      if (window.scrollY > window.innerHeight * 0.3) return;

      // If graph is zoomed in at all (below base), capture ALL wheel for graph zoom
      if (targetZoom < BASE_ZOOM - 10) {
        e.preventDefault();
        // Update zoom focus when zooming in further
        if (e.deltaY < 0) { zoomFocus.set(mouse.x, mouse.y); }
        targetZoom += e.deltaY * 2;
        targetZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, targetZoom));
        // Clamp so it doesn't overshoot past base when zooming out
        if (targetZoom > BASE_ZOOM) targetZoom = BASE_ZOOM;
        return;
      }

      // At default zoom level
      if (e.deltaY < 0) {
        // Scrolling up / zooming in — zoom the graph
        e.preventDefault();
        zoomFocus.set(mouse.x, mouse.y); // capture zoom direction
        targetZoom += e.deltaY * 2;
        targetZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, targetZoom));
      } else {
        // Scrolling down at default zoom — bridge to page scroll
        window.scrollBy({ top: e.deltaY * 0.8, behavior: 'auto' });
      }
    }, { passive: false });

    // ================================================================
    // TOUCH CONTROLS — pinch zoom, single-finger drag, tap/hold for tooltip
    // ================================================================
    let touchStartDist = 0;
    let touchStartZoom = BASE_ZOOM;
    let touchDragId = null;
    let touchStartX = 0, touchStartY = 0;
    let touchHoldTimer = null;
    let touchMoved = false;

    let isTouchPinching = false;
    let isTouchRotating = false; // true once horizontal drag detected

    renderer.domElement.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault(); // prevent pull-to-refresh / browser zoom during pinch
        isTouchPinching = true;
        isTouchRotating = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchStartDist = Math.sqrt(dx * dx + dy * dy);
        touchStartZoom = targetZoom;
        // Capture initial pinch center for directional zoom
        const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
        const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
        zoomFocus.set((cx / window.innerWidth) * 2 - 1, -(cy / window.innerHeight) * 2 + 1);
        if (touchHoldTimer) { clearTimeout(touchHoldTimer); touchHoldTimer = null; }
      } else if (e.touches.length === 1) {
        // When zoomed in, prevent default to block pull-to-refresh on single touch too
        if (targetZoom < BASE_ZOOM - 10) e.preventDefault();
        const t = e.touches[0];
        touchDragId = t.identifier;
        touchStartX = t.clientX;
        touchStartY = t.clientY;
        touchMoved = false;
        isTouchPinching = false;
        isTouchRotating = false;
        dragStartX = t.clientX;
        dragStartY = t.clientY;
        lastDragX = t.clientX;
        lastDragY = t.clientY;

        // Hold timer for tooltip (400ms hold without moving)
        touchHoldTimer = setTimeout(() => {
          if (!touchMoved) {
            doRaycast(t.clientX, t.clientY);
            if (hoveredMesh) {
              isHoldingNode = true; // pause auto-rotation while holding node
              // Toggle leader label in search mode
              if (searchActive) {
                const nodeIdx = hoveredMesh.userData.nodeIndex;
                const found = findSelectionForNode(nodeIdx);
                if (found) toggleLeaderLabel(found.key, found.sel.name, found.indices);
              }
              if (pinnedMesh === hoveredMesh) {
                pinnedMesh = null; unhighlightNode(); hideTooltip();
              } else {
                pinnedMesh = hoveredMesh;
                const d = hoveredMesh.userData.langData;
                highlightNode(hoveredMesh);
                showTooltip(d, t.clientX, t.clientY, true);
              }
            }
          }
          touchHoldTimer = null;
        }, 400);
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2 || isTouchPinching) {
        e.preventDefault();
        isTouchPinching = true;
        if (touchHoldTimer) { clearTimeout(touchHoldTimer); touchHoldTimer = null; }
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const scale = touchStartDist / dist;
        const prevZoom = targetZoom;
        targetZoom = Math.max(ZOOM_MIN, Math.min(ZOOM_MAX, touchStartZoom * scale));
        // Update zoom focus to pinch center when zooming in
        if (targetZoom < prevZoom) {
          const cx = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const cy = (e.touches[0].clientY + e.touches[1].clientY) / 2;
          zoomFocus.set((cx / window.innerWidth) * 2 - 1, -(cy / window.innerHeight) * 2 + 1);
        }
      } else if (e.touches.length === 1) {
        const t = e.touches[0];
        const dx = t.clientX - touchStartX;
        const dy = t.clientY - touchStartY;
        const absDx = Math.abs(dx), absDy = Math.abs(dy);

        if (!touchMoved && absDx + absDy > 10) {
          touchMoved = true;
          if (touchHoldTimer) { clearTimeout(touchHoldTimer); touchHoldTimer = null; }
          // Decide: horizontal-dominant = graph rotate, vertical = page scroll
          if (absDx > absDy * 1.2) {
            isTouchRotating = true;
            isDragging = true;
            lastDragX = t.clientX;
            lastDragY = t.clientY;
          }
        }

        // When zoomed in, capture ALL single-finger movement for graph rotation
        // (prevents pull-to-refresh and keeps user in graph-interaction mode)
        if (targetZoom < BASE_ZOOM - 10) {
          e.preventDefault();
          if (!isTouchRotating && touchMoved) {
            isTouchRotating = true;
            isDragging = true;
            lastDragX = t.clientX;
            lastDragY = t.clientY;
          }
        }

        if (isTouchRotating) {
          e.preventDefault();
          const tdx = t.clientX - lastDragX;
          const tdy = t.clientY - lastDragY;
          lastDragX = t.clientX;
          lastDragY = t.clientY;
          const tRotScale = 0.004 * Math.max(0.25, camera.position.z / BASE_ZOOM);
          _deltaQuat.setFromAxisAngle(_rotYAxis, tdx * tRotScale);
          orientationQuat.premultiply(_deltaQuat);
          _deltaQuat.setFromAxisAngle(_rotXAxis, tdy * tRotScale);
          orientationQuat.premultiply(_deltaQuat);
        }
        // At default zoom, vertical-dominant: no preventDefault, page scrolls naturally
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchend', (e) => {
      if (touchHoldTimer) { clearTimeout(touchHoldTimer); touchHoldTimer = null; }
      isTouchPinching = false;
      isHoldingNode = false; // resume auto-rotation when finger lifts
      if (e.touches.length === 0) {
        isDragging = false;
        isTouchRotating = false;
        // Quick tap — toggle tooltip + leader labels
        if (!touchMoved) {
          doRaycast(touchStartX, touchStartY);
          if (hoveredMesh) {
            // Toggle leader label in search mode
            if (searchActive) {
              const nodeIdx = hoveredMesh.userData.nodeIndex;
              const found = findSelectionForNode(nodeIdx);
              if (found) toggleLeaderLabel(found.key, found.sel.name, found.indices);
            }
            if (pinnedMesh === hoveredMesh) {
              pinnedMesh = null; unhighlightNode(); hideTooltip();
            } else {
              pinnedMesh = hoveredMesh;
              const d = hoveredMesh.userData.langData;
              highlightNode(hoveredMesh);
              showTooltip(d, touchStartX, touchStartY, true);
            }
          } else {
            // No node — check edge tap for label toggle
            if (searchActive) {
              const edgeIdx = findNearestEdge(touchStartX, touchStartY);
              if (edgeIdx !== null) {
                const found = findSelectionForEdge(edgeIdx);
                if (found) {
                  toggleLeaderLabel(found.key, found.sel.name, found.indices);
                }
              }
            }
            if (pinnedMesh) {
              pinnedMesh = null; unhighlightNode(); hideTooltip();
            }
          }
        }
      }
    }, { passive: false });

    renderer.domElement.addEventListener('touchcancel', () => {
      if (touchHoldTimer) { clearTimeout(touchHoldTimer); touchHoldTimer = null; }
      isDragging = false;
      isTouchRotating = false;
      isHoldingNode = false;
    });

    // ================================================================
    // TOOLTIP — RAYCASTER + TIME PERIODS + INTERACTION
    // ================================================================
    const raycaster = new THREE.Raycaster();
    raycaster.params.Mesh = { threshold: 0.5 };
    const tooltipEl = document.getElementById('tooltip');
    let hoveredMesh = null;
    let pinnedMesh = null;
    let lastMouseX = 0, lastMouseY = 0;

    // Family proto-language origin dates (years, negative = BC)
    const FAMILY_ORIGINS = {
      'Afroasiatic':-10000,'Niger-Congo':-5000,'Nilo-Saharan':-6000,
      'Indo-European':-4500,'Uralic':-5000,'Kartvelian':-3000,
      'Northeast Caucasian':-4000,'Northwest Caucasian':-3000,
      'Sino-Tibetan':-5200,'Austronesian':-3500,'Austroasiatic':-3000,
      'Kra-Dai':-2500,'Dravidian':-2500,'Hmong-Mien':-4000,
      'Turkic':-500,'Mongolic':200,'Tungusic':500,
      'Japonic':-300,'Koreanic':-300,
      'Algic':-2500,'Na-Dene':-3000,'Uto-Aztecan':-3000,
      'Mayan':-2000,'Oto-Manguean':-3500,'Quechuan':-1000,
      'Tupian':-2000,'Arawakan':-2500,'Cariban':-2000,
      'Chibchan':-2000,'Aymaran':-1500,
      'Eskimo-Aleut':-3000,'Iroquoian':-1500,'Siouan':-1500,
      'Salishan':-2000,'Trans-New Guinea':-8000,'Pama-Nyungan':-5000,
      'Khoe-Kwadi':-2000,'Kx\'a':-10000,'Tuu':-10000,
    };

    // Well-known language dates override (sourced from Britannica, Glottolog, Ethnologue)
    const KNOWN_DATES = {
      // Proto-languages
      lang_proto_indo_european:'c. 4500 – 2500 BC',
      lang_proto_germanic:'c. 500 BC – 200 AD',
      lang_proto_celtic:'c. 800 – 300 BC',
      lang_proto_italic:'c. 1000 – 500 BC',
      lang_proto_slavic:'c. 200 BC – 500 AD',
      lang_proto_balto_slavic:'c. 1500 – 500 BC',
      lang_proto_indo_iranian:'c. 2500 – 1500 BC',
      lang_proto_anatolian:'c. 3500 – 2000 BC',
      lang_proto_sino_tibetan:'c. 5200 – 4000 BC',
      lang_proto_austronesian:'c. 3500 – 3000 BC',
      lang_proto_afroasiatic:'c. 10000 – 8000 BC',
      lang_proto_semitic:'c. 4000 – 3000 BC',
      lang_proto_niger_congo:'c. 5000 – 3000 BC',
      lang_proto_bantu:'c. 3000 – 2000 BC',
      lang_proto_uralic:'c. 5000 – 3000 BC',
      lang_proto_turkic:'c. 500 BC – 100 AD',
      lang_proto_dravidian:'c. 2500 – 1500 BC',
      // Anatolian
      lang_hittite:'c. 1650 – 1180 BC',lang_palaic:'c. 1500 – 1300 BC',
      lang_cuneiform_luwian:'c. 1400 – 1200 BC',lang_lydian:'c. 700 – 200 BC',
      lang_lycian:'c. 500 – 200 BC',lang_carian:'c. 600 – 200 BC',
      // Tocharian
      lang_tocharian_a:'c. 600 – 900 AD',lang_tocharian_b:'c. 600 – 1000 AD',
      // Greek
      lang_mycenaean_greek:'c. 1600 – 1100 BC',lang_ancient_greek:'c. 800 – 300 BC',
      lang_koine_greek:'c. 300 BC – 600 AD',lang_medieval_greek:'c. 600 – 1453 AD',
      lang_modern_greek:'c. 1453 – present',
      // Italic / Romance
      lang_latin:'c. 700 BC – 600 AD',lang_oscan:'c. 500 – 100 BC',
      lang_umbrian:'c. 500 – 100 BC',lang_old_french:'c. 842 – 1300 AD',
      lang_french:'c. 1500 – present',lang_spanish:'c. 1200 – present',
      lang_portuguese:'c. 1200 – present',lang_italian:'c. 1300 – present',
      lang_romanian:'c. 1500 – present',lang_catalan:'c. 1200 – present',
      // Celtic
      lang_gaulish:'c. 600 BC – 500 AD',lang_celtiberian:'c. 200 BC – 100 AD',
      lang_old_irish:'c. 600 – 900 AD',lang_middle_irish:'c. 900 – 1200 AD',
      lang_irish:'c. 1200 – present',lang_welsh:'c. 600 – present',
      lang_scottish_gaelic:'c. 1300 – present',lang_breton:'c. 600 – present',
      // Germanic
      lang_gothic:'c. 350 – 600 AD',lang_old_english:'c. 450 – 1100 AD',
      lang_middle_english:'c. 1100 – 1500 AD',lang_english:'c. 1500 – present',
      lang_old_norse:'c. 700 – 1300 AD',lang_old_high_german:'c. 750 – 1050 AD',
      lang_middle_high_german:'c. 1050 – 1350 AD',lang_german:'c. 1500 – present',
      lang_dutch:'c. 1500 – present',lang_swedish:'c. 1500 – present',
      lang_danish:'c. 1500 – present',lang_norwegian:'c. 1500 – present',
      lang_icelandic:'c. 1200 – present',
      // Slavic
      lang_old_church_slavonic:'c. 860 – 1100 AD',
      lang_russian:'c. 1400 – present',lang_polish:'c. 1000 – present',
      lang_czech:'c. 1300 – present',lang_ukrainian:'c. 1400 – present',
      lang_serbian:'c. 1200 – present',lang_croatian:'c. 1200 – present',
      lang_bulgarian:'c. 900 – present',
      // Armenian & Albanian
      lang_classical_armenian:'c. 405 – 1100 AD',
      lang_eastern_armenian:'c. 1700 – present',lang_western_armenian:'c. 1700 – present',
      // Indo-Iranian
      lang_vedic_sanskrit:'c. 1500 – 500 BC',lang_sanskrit:'c. 500 BC – 300 AD',
      lang_pali:'c. 600 BC – present',lang_avestan:'c. 1200 – 400 BC',
      lang_old_persian:'c. 525 – 300 BC',lang_middle_persian:'c. 300 BC – 700 AD',
      lang_persian:'c. 800 – present',lang_hindi:'c. 1300 – present',
      lang_urdu:'c. 1500 – present',lang_bengali:'c. 1000 – present',
      lang_punjabi:'c. 1000 – present',lang_marathi:'c. 1100 – present',
      lang_gujarati:'c. 1200 – present',lang_nepali:'c. 1300 – present',
      lang_sinhalese:'c. 300 BC – present',lang_kurdish:'c. 800 – present',
      // Uralic
      lang_finnish:'c. 1500 – present',lang_estonian:'c. 1500 – present',
      lang_hungarian:'c. 1000 – present',
      // Semitic
      lang_akkadian:'c. 2800 – 500 BC',lang_eblaite:'c. 2400 – 2250 BC',
      lang_phoenician:'c. 1050 – 150 BC',
      lang_biblical_hebrew:'c. 1200 – 200 BC',lang_hebrew:'c. 1880 – present',
      lang_aramaic:'c. 1100 BC – present',lang_arabic:'c. 600 – present',
      lang_ge_ez:'c. 400 BC – present (liturgical)',
      lang_amharic:'c. 1300 – present',lang_tigrinya:'c. 1300 – present',
      // Egyptian
      lang_ancient_egyptian:'c. 3200 – 600 BC',lang_coptic:'c. 200 – 1600 AD',
      // Sino-Tibetan
      lang_old_chinese:'c. 1250 – 200 BC',lang_middle_chinese:'c. 600 – 1200 AD',
      lang_mandarin:'c. 1350 – present',lang_cantonese:'c. 1000 – present',
      lang_classical_tibetan:'c. 650 – present (literary)',
      lang_burmese:'c. 1100 – present',
      // Japonic & Koreanic
      lang_old_japanese:'c. 700 – 800 AD',lang_middle_japanese:'c. 800 – 1600 AD',
      lang_japanese:'c. 1600 – present',
      lang_old_korean:'c. 500 – 935 AD',lang_middle_korean:'c. 935 – 1600 AD',
      lang_korean:'c. 1600 – present',
      // Turkic
      lang_old_turkic:'c. 550 – 1200 AD',lang_turkish:'c. 1300 – present',
      lang_azerbaijani:'c. 1100 – present',lang_uzbek:'c. 1400 – present',
      // Austronesian
      lang_malay:'c. 700 – present',lang_javanese:'c. 800 – present',
      lang_tagalog:'c. 900 – present',lang_hawaiian:'c. 1000 – present',
      lang_maori:'c. 1200 – present',lang_malagasy:'c. 800 – present',
      // African
      lang_swahili:'c. 1100 – present',lang_zulu:'c. 1600 – present',
      lang_yoruba:'c. 1000 – present',lang_hausa:'c. 1000 – present',
      lang_igbo:'c. 900 – present',lang_somali:'c. 1200 – present',
      lang_oromo:'c. 1400 – present',lang_wolof:'c. 1200 – present',
      // Americas
      lang_classical_nahuatl:'c. 1300 – 1600 AD',lang_nahuatl:'c. 1600 – present',
      lang_navajo:'c. 1400 – present',lang_quechua:'c. 1400 – present',
      lang_guarani:'c. 1400 – present',lang_cherokee:'c. 1300 – present',
      lang_maya:'c. 1000 – present',lang_aymara:'c. 1200 – present',
      // Isolates & ancient
      lang_basque:'c. 1000 BC – present',lang_sumerian:'c. 3500 – 2000 BC',
      lang_elamite:'c. 2600 – 400 BC',lang_etruscan:'c. 700 – 100 BC',
      lang_hurrian:'c. 2300 – 1200 BC',lang_urartian:'c. 860 – 585 BC',
      lang_manchu:'c. 1600 – present',lang_ainu:'c. 1300 – present',
    };

    // Max depth per family (cached)
    const familyMaxDepth = {};
    graphData.nodes.forEach(n => {
      familyMaxDepth[n.family] = Math.max(familyMaxDepth[n.family] || 0, n.depth);
    });

    function formatYear(y) {
      if (y < 0) return `${Math.abs(y)} BC`;
      return `AD ${y}`;
    }

    function estimateTimePeriod(d) {
      if (KNOWN_DATES[d.id]) return KNOWN_DATES[d.id];

      const depth = typeof d.depth === 'number' ? d.depth : 0;
      const origin = FAMILY_ORIGINS[d.family] || -2000;
      const maxD = Math.max(1, familyMaxDepth[d.family] || 1);
      const ratio = Math.min(1, depth / maxD);
      const startYear = Math.round(origin + (2026 - origin) * ratio);

      if (isNaN(startYear)) {
        if (d.status === 'alive') return 'Modern era – present';
        if (d.status === 'extinct') return 'Historical';
        return 'Unknown period';
      }

      if (d.name.startsWith('Proto-')) {
        return `c. ${formatYear(startYear)} (reconstructed)`;
      }

      if (d.status === 'alive' || d.status === 'moribund') {
        const age = Math.max(80, Math.round((2026 - origin) / maxD * 0.6));
        const start = startYear - age;
        return `c. ${formatYear(start)} – present`;
      }

      // Extinct
      const lifespan = Math.max(150, Math.round((2026 - origin) / maxD * 0.45));
      const end = Math.min(2026, startYear + Math.round(lifespan * 0.5));
      return `c. ${formatYear(startYear)} – ${formatYear(end)}`;
    }

    function formatSpeakers(n) {
      if (!n || n <= 0) return null;
      if (n >= 1e9) return `~${(n/1e9).toFixed(1)}B`;
      if (n >= 1e6) return `~${(n/1e6).toFixed(1)}M`;
      if (n >= 1e3) return `~${(n/1e3).toFixed(1)}K`;
      return `~${n}`;
    }

    function buildTooltipHTML(d, pinned) {
      const statusClass = `tt-status-${d.status}`;
      const statusLabel = d.status === 'alive' ? 'Living' :
                          d.status === 'moribund' ? 'Moribund' : 'Extinct';
      const period = estimateTimePeriod(d);
      const speakers = formatSpeakers(d.speakers);
      const branch = d.branch || '(root)';
      const desc = d.descendants;

      let html = '';
      if (pinned) html += '<span class="tt-pinned">[ PINNED ]</span>';
      html += `<div class="tt-header">> ${d.name}</div>`;
      html += `<div class="tt-row"><span class="tt-label">family</span><span class="tt-value">${d.family}</span></div>`;
      html += `<div class="tt-row"><span class="tt-label">branch</span><span class="tt-value">${branch}</span></div>`;
      html += `<div class="tt-row"><span class="tt-label">period</span><span class="tt-value">${period}</span></div>`;
      html += `<div class="tt-row"><span class="tt-label">status</span><span class="tt-value ${statusClass}">${statusLabel}</span></div>`;
      if (speakers) {
        html += `<div class="tt-row"><span class="tt-label">speakers</span><span class="tt-value">${speakers}</span></div>`;
      }
      html += `<div class="tt-row"><span class="tt-label">region</span><span class="tt-value">${d.continent}</span></div>`;
      if (desc > 0) {
        html += `<div class="tt-row"><span class="tt-label">descendants</span><span class="tt-value">${desc} language${desc > 1 ? 's' : ''}</span></div>`;
      }
      return html;
    }

    function showTooltip(d, x, y, pinned) {
      tooltipEl.innerHTML = buildTooltipHTML(d, pinned);
      tooltipEl.style.display = 'block';
      // Position: offset from cursor, keep within viewport
      const pad = 12;
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const rect = tooltipEl.getBoundingClientRect();
      let tx = x + pad;
      let ty = y + pad;
      // Flip left if overflowing right
      if (tx + rect.width > vw - pad) tx = x - rect.width - pad;
      // Flip up if overflowing bottom
      if (ty + rect.height > vh - pad) ty = y - rect.height - pad;
      // Final clamp: never allow off-screen on any edge
      tx = Math.max(pad, Math.min(tx, vw - rect.width - pad));
      ty = Math.max(pad, Math.min(ty, vh - rect.height - pad));
      tooltipEl.style.left = tx + 'px';
      tooltipEl.style.top = ty + 'px';
    }

    function hideTooltip() {
      tooltipEl.style.display = 'none';
    }

    // No-op highlight — keep original node color
    function highlightNode(mesh) {}
    function unhighlightNode() {}

    // Raycast on mousemove (throttled)
    let raycastTimer = null;
    window.addEventListener('mousemove', (e) => {
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      if (isDragging) return; // keep tooltip visible while dragging
      if (raycastTimer) return;
      raycastTimer = setTimeout(() => {
        raycastTimer = null;
        doRaycast(e.clientX, e.clientY);
      }, 30);
    });

    function doRaycast(mx, my) {
      const ndc = new THREE.Vector2(
        (mx / window.innerWidth) * 2 - 1,
        -(my / window.innerHeight) * 2 + 1
      );
      raycaster.setFromCamera(ndc, camera);
      const hits = raycaster.intersectObjects(nodeMeshes, false);

      if (hits.length > 0) {
        const mesh = hits[0].object;
        const d = mesh.userData.langData;
        hoveredMesh = mesh;
        highlightNode(mesh);
        if (!pinnedMesh) showTooltip(d, mx, my, false);
        renderer.domElement.style.cursor = 'pointer';
      } else {
        hoveredMesh = null;
        if (!pinnedMesh) { hideTooltip(); unhighlightNode(); }
        if (!isDragging) renderer.domElement.style.cursor = 'grab';
      }
    }

    // --- Leader-label click helpers ---
    function pointToSegmentDist(px, py, ax, ay, bx, by) {
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      const t = Math.max(0, Math.min(1, (apx * abx + apy * aby) / (abx * abx + aby * aby + 1e-12)));
      const cx = ax + t * abx, cy = ay + t * aby;
      return Math.hypot(px - cx, py - cy);
    }

    function findNearestEdge(mx, my, maxDist) {
      if (!maxDist) maxDist = 12;
      let bestDist = maxDist + 1, bestIdx = -1;
      const tmpA = new THREE.Vector3();
      const tmpB = new THREE.Vector3();
      for (const ei of searchHighlightedEdges) {
        const edge = graphData.edges[ei];
        nodeMeshes[edge.sourceIdx].getWorldPosition(tmpA);
        tmpA.project(camera);
        const sx1 = (tmpA.x * 0.5 + 0.5) * window.innerWidth;
        const sy1 = (-tmpA.y * 0.5 + 0.5) * window.innerHeight;
        nodeMeshes[edge.targetIdx].getWorldPosition(tmpB);
        tmpB.project(camera);
        const sx2 = (tmpB.x * 0.5 + 0.5) * window.innerWidth;
        const sy2 = (-tmpB.y * 0.5 + 0.5) * window.innerHeight;
        const d = pointToSegmentDist(mx, my, sx1, sy1, sx2, sy2);
        if (d < bestDist) { bestDist = d; bestIdx = ei; }
      }
      return bestIdx >= 0 ? bestIdx : null;
    }

    function findSelectionForNode(nodeIdx) {
      // Prefer family/branch over language
      let langKey = null;
      for (const [key, sel] of searchSelections) {
        const indices = getNodeIndicesForSelection(sel);
        if (indices.has(nodeIdx)) {
          if (sel.type === 'family' || sel.type === 'branch') return { key, sel, indices };
          if (!langKey) langKey = { key, sel, indices };
        }
      }
      return langKey || null;
    }

    function findSelectionForEdge(edgeIdx) {
      const edge = graphData.edges[edgeIdx];
      for (const [key, sel] of searchSelections) {
        const indices = getNodeIndicesForSelection(sel);
        if (indices.has(edge.sourceIdx) && indices.has(edge.targetIdx)) {
          if (sel.type === 'family' || sel.type === 'branch') return { key, sel, indices };
        }
      }
      // Fallback: any selection containing both
      for (const [key, sel] of searchSelections) {
        const indices = getNodeIndicesForSelection(sel);
        if (indices.has(edge.sourceIdx) && indices.has(edge.targetIdx)) {
          return { key, sel, indices };
        }
      }
      return null;
    }

    // Click to pin/unpin tooltip + leader-label toggle
    window.addEventListener('click', (e) => {
      // Ignore if drag was significant
      const dx = e.clientX - dragStartX;
      const dy = e.clientY - dragStartY;
      if (Math.abs(dx) + Math.abs(dy) > 6) return;

      if (hoveredMesh) {
        // In search mode: toggle leader label for the selection owning this node
        if (searchActive) {
          const nodeIdx = hoveredMesh.userData.nodeIndex;
          const found = findSelectionForNode(nodeIdx);
          if (found) {
            toggleLeaderLabel(found.key, found.sel.name, found.indices);
          }
        }
        // Normal tooltip pin/unpin still applies
        if (pinnedMesh === hoveredMesh) {
          pinnedMesh = null;
          unhighlightNode();
          hideTooltip();
        } else {
          pinnedMesh = hoveredMesh;
          const d = hoveredMesh.userData.langData;
          highlightNode(hoveredMesh);
          showTooltip(d, e.clientX, e.clientY, true);
        }
      } else {
        // No node hit — check for edge click in search mode
        if (searchActive) {
          const edgeIdx = findNearestEdge(e.clientX, e.clientY);
          if (edgeIdx !== null) {
            const found = findSelectionForEdge(edgeIdx);
            if (found) {
              toggleLeaderLabel(found.key, found.sel.name, found.indices);
              return; // Don't unpin tooltip on edge click
            }
          }
        }
        // Click empty space — unpin
        if (pinnedMesh) {
          pinnedMesh = null;
          unhighlightNode();
          hideTooltip();
        }
      }
    });

    // ================================================================
    // ANIMATION LOOP
    // ================================================================
    const clock = new THREE.Clock();
    const NODE_FADE_DUR = 0.6;

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      globalElapsed += dt;
      phaseTime += dt;

      let steadyMix, globalAlpha;

      // Search mode: per-edge independent cascade → steady transitions (shader-driven)
      if (searchActive) {
        searchCascadeTime += dt;
        cascadeTime = searchCascadeTime;
        steadyMix = 0;   // shader computes per-edge steady via uSearchMode
        globalAlpha = 1;
      } else {
      // Startup: sequential all-family cascade → settle → steady
      // Then loop: fadeout → dark → single-family cascade → familySettle → steady → ...
      switch (phase) {
        case 'cascade':
          cascadeTime += dt;
          steadyMix = 0;
          globalAlpha = 1;
          if (isFirstCascade) {
            // Startup cascade — wait for all families to finish then settle
            if (phaseTime >= startupCascadeDuration) { phase = 'settle'; phaseTime = 0; }
          } else {
            // Single-family cascade — 5s burst then settle back to full colorful state
            if (phaseTime >= 7) { phase = 'familySettle'; phaseTime = 0; }
          }
          break;
        case 'settle':
          // Only used after startup: transition from cascade glow to steady fiber-optic
          cascadeTime += dt;
          steadyMix = Math.min(1, phaseTime / SETTLE_DUR);
          steadyMix = steadyMix * steadyMix * (3 - 2 * steadyMix);
          globalAlpha = 1;
          if (phaseTime >= SETTLE_DUR) { phase = 'steady'; phaseTime = 0; }
          break;
        case 'steady':
          // All families visible with fiber-optic edges
          cascadeFamily = null;
          isFirstCascade = false;
          steadyMix = 1; globalAlpha = 1;
          if (phaseTime >= STEADY_DUR) { phase = 'fadeout'; phaseTime = 0; }
          break;
        case 'fadeout':
          // Fade all edges before going dark
          steadyMix = 1;
          globalAlpha = 1 - Math.min(1, phaseTime / FADEOUT_DUR);
          globalAlpha *= globalAlpha;
          if (phaseTime >= FADEOUT_DUR) { phase = 'dark'; phaseTime = 0; }
          break;
        case 'dark':
          // Brief darkness then start single-family cascade
          steadyMix = 0; globalAlpha = 0;
          if (phaseTime >= DARK_DUR) { startNewCascade(); phase = 'cascade'; phaseTime = 0; }
          break;
        case 'familySettle':
          // After single-family cascade, transition back to full colorful steady state
          cascadeTime += dt;
          cascadeFamily = null; // all families now
          steadyMix = Math.min(1, phaseTime / SETTLE_DUR);
          steadyMix = steadyMix * steadyMix * (3 - 2 * steadyMix);
          globalAlpha = 1;
          if (phaseTime >= SETTLE_DUR) { phase = 'steady'; phaseTime = 0; }
          break;
      }
      } // end else (!searchActive)

      // Rotation — quaternion-based (no gimbal lock)
      if (!isDragging && !isHoldingNode) {
        _deltaQuat.setFromAxisAngle(_rotYAxis, dt * 0.06);
        orientationQuat.premultiply(_deltaQuat);
      }
      worldGroup.quaternion.copy(orientationQuat);
      // Subtle mouse parallax tilt when not dragging
      if (!isDragging) {
        _deltaQuat.setFromAxisAngle(_rotXAxis, mouse.y * 0.002);
        worldGroup.quaternion.multiply(_deltaQuat);
      }
      camera.position.z += (targetZoom - camera.position.z) * 0.08;
      window._graphZoom.target = targetZoom;
      window._graphZoom.base = BASE_ZOOM;

      // Directional zoom: shift camera X/Y toward zoom focus when zoomed in
      const zoomDepth = Math.max(0, (BASE_ZOOM - targetZoom) / (BASE_ZOOM - ZOOM_MIN));
      const maxShift = 550 * zoomDepth; // approximate graph radius
      targetCamX = zoomFocus.x * maxShift;
      targetCamY = zoomFocus.y * maxShift;
      // Smooth lerp — slightly slower than zoom for a flowing feel
      camera.position.x += (targetCamX - camera.position.x) * 0.06;
      camera.position.y += (targetCamY - camera.position.y) * 0.06;
      // Always look at the graph center — keeps rotation pivot on screen
      camera.lookAt(0, 0, 0);

      // Dynamically toggle touch-action and overscroll based on zoom state
      // When zoomed in: lock touch to canvas (no browser scroll/pull-to-refresh)
      // When at default zoom: allow vertical pan for page scroll
      const isZoomedIn = targetZoom < BASE_ZOOM - 10;
      const canvasTA = renderer.domElement.style.touchAction;
      if (isZoomedIn && canvasTA !== 'none') {
        renderer.domElement.style.touchAction = 'none';
      } else if (!isZoomedIn && canvasTA !== 'pan-y') {
        renderer.domElement.style.touchAction = 'pan-y';
      }

      // Update nodes
      for (let i = 0; i < NODE_COUNT; i++) {
        const node = graphData.nodes[i];
        const mesh = nodeMeshes[i];
        const ud = mesh.userData;

        let targetOp;
        const isHighlighted = searchActive && searchHighlightedNodes.has(i);
        const isDimmedBySearch = searchActive && !searchHighlightedNodes.has(i);

        if (searchActive) {
          // Search mode: each node independently fades in based on its own reveal time
          if (isHighlighted) {
            const tr = searchCascadeTime - node.cascadeRevealTime;
            if (tr <= 0) {
              targetOp = 0.08;
            } else {
              const fadeIn = Math.min(1, tr / NODE_FADE_DUR);
              targetOp = 0.08 + fadeIn * (0.85 + node.recency * 0.15);
            }
          } else {
            targetOp = 0.04;
          }
        } else {
        const isActiveFamily = !cascadeFamily || node.family === cascadeFamily;
        if (phase === 'cascade' || phase === 'settle') {
          if (isActiveFamily) {
            const tr = cascadeTime - node.cascadeRevealTime;
            const fadeIn = Math.max(0, Math.min(1, tr / NODE_FADE_DUR));
            targetOp = 0.08 + fadeIn * (0.85 + node.recency * 0.15);
          } else {
            // Non-active family: dimmed but visible floating orbs
            targetOp = 0.15;
          }
        } else if (phase === 'steady' || phase === 'familySettle') {
          targetOp = 0.85 + node.recency * 0.15;
        } else if (phase === 'fadeout') {
          targetOp = (0.85 + node.recency * 0.15) * globalAlpha;
        } else if (phase === 'dark') {
          // All nodes dimmed but visible between cascades
          targetOp = 0.08;
        } else {
          targetOp = 0;
        }
        } // end else (!searchActive)

        ud.currentOpacity += (targetOp - ud.currentOpacity) * Math.min(1, dt * 4);
        mesh.material.opacity = ud.currentOpacity;

        const pulse = 1 + 0.04 * Math.sin(globalElapsed * 1.2 + i * 0.5);
        let scaleMul = 1;
        if (searchActive) {
          // Search mode: each node independently cascade-grows based on its own reveal time
          if (isHighlighted) {
            const tr = searchCascadeTime - node.cascadeRevealTime;
            if (tr < 0) scaleMul = 0.3;
            else if (tr < 0.5) scaleMul = 0.3 + 0.7 * (1 - Math.pow(1 - tr / 0.5, 3));
            // else: fully grown → scaleMul stays 1
          } else {
            scaleMul = 0.5;
          }
        } else {
        if (phase === 'cascade' && (!cascadeFamily || node.family === cascadeFamily)) {
          const tr = cascadeTime - node.cascadeRevealTime;
          if (tr < 0) scaleMul = 0.3;
          else if (tr < 0.5) scaleMul = 0.3 + 0.7 * (1 - Math.pow(1 - tr / 0.5, 3));
        } else if (phase === 'cascade' && cascadeFamily && node.family !== cascadeFamily) {
          scaleMul = 0.7;
        } else if (phase === 'dark') {
          scaleMul = 0.7;
        }
        } // end else (!searchActive)
        mesh.scale.setScalar(ud.baseSize * pulse * scaleMul);
        mesh.position.copy(node.position);
      }

      // Update leader-line labels (follows globe rotation)
      updateLeaderLabels(dt);

      // Update edge positions (static — just needs first-frame copy)
      if (globalElapsed < 0.1) {
        const posAttr = edgeGeo.getAttribute('position');
        let vi = 0;
        for (const edge of graphData.edges) {
          const a = graphData.nodes[edge.sourceIdx].position;
          const b = graphData.nodes[edge.targetIdx].position;
          for (let s = 0; s < SEGMENTS_PER_EDGE; s++) {
            const t0 = s / SEGMENTS_PER_EDGE;
            const t1 = (s + 1) / SEGMENTS_PER_EDGE;
            posAttr.array[vi*3]=a.x+(b.x-a.x)*t0; posAttr.array[vi*3+1]=a.y+(b.y-a.y)*t0; posAttr.array[vi*3+2]=a.z+(b.z-a.z)*t0; vi++;
            posAttr.array[vi*3]=a.x+(b.x-a.x)*t1; posAttr.array[vi*3+1]=a.y+(b.y-a.y)*t1; posAttr.array[vi*3+2]=a.z+(b.z-a.z)*t1; vi++;
          }
        }
        posAttr.needsUpdate = true;
      }

      edgeMat.uniforms.uTime.value = globalElapsed;
      edgeMat.uniforms.uCascadeTime.value = cascadeTime;
      edgeMat.uniforms.uSteadyMix.value = steadyMix;
      edgeMat.uniforms.uGlobalAlpha.value = globalAlpha;
      edgeMat.uniforms.uSearchMode.value = searchActive ? 1.0 : 0.0;
      edgeMat.uniforms.uGrowDuration.value = isFirstCascade ? STARTUP_GROW : EDGE_GROW_DUR;

      // Update pinned tooltip position (follows node through rotation)
      if (pinnedMesh) {
        const pos = new THREE.Vector3();
        pinnedMesh.getWorldPosition(pos);
        pos.project(camera);
        const sx = (pos.x * 0.5 + 0.5) * window.innerWidth;
        const sy = (-pos.y * 0.5 + 0.5) * window.innerHeight;
        showTooltip(pinnedMesh.userData.langData, sx, sy, true);
      }

      composer.render();
    }

    animate();

    // Graph is ready — start the typewriter subtitle in sync
    if (window._startTypewriter) window._startTypewriter();

    // ================================================================
    // RESIZE
    // ================================================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
